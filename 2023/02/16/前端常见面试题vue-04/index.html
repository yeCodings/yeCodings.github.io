<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端常见vue面试题(一) | yecoding Blog </title>
    <meta name="generator" content="VuePress 1.9.8">
    
    <meta name="description" content="This is a blog example built by VuePress">
    
    <link rel="preload" href="/assets/css/0.styles.8f4760b9.css" as="style"><link rel="preload" href="/assets/js/app.910dc115.js" as="script"><link rel="preload" href="/assets/js/4.5b8d8b22.js" as="script"><link rel="preload" href="/assets/js/17.b3c10cd1.js" as="script"><link rel="preload" href="/assets/js/6.d2ea23d8.js" as="script"><link rel="prefetch" href="/assets/js/10.dcbecad9.js"><link rel="prefetch" href="/assets/js/11.bc878eb5.js"><link rel="prefetch" href="/assets/js/12.7ad4a89b.js"><link rel="prefetch" href="/assets/js/13.c961a1cb.js"><link rel="prefetch" href="/assets/js/14.95c14d5f.js"><link rel="prefetch" href="/assets/js/15.554403c9.js"><link rel="prefetch" href="/assets/js/16.08abd0f0.js"><link rel="prefetch" href="/assets/js/18.6e7e20b1.js"><link rel="prefetch" href="/assets/js/19.d462b7fe.js"><link rel="prefetch" href="/assets/js/20.6f403a75.js"><link rel="prefetch" href="/assets/js/21.8a262424.js"><link rel="prefetch" href="/assets/js/22.c0bf7021.js"><link rel="prefetch" href="/assets/js/23.243528c8.js"><link rel="prefetch" href="/assets/js/3.70520c45.js"><link rel="prefetch" href="/assets/js/5.9cf19b34.js"><link rel="prefetch" href="/assets/js/7.b101bcbb.js"><link rel="prefetch" href="/assets/js/8.ab8a61c9.js"><link rel="prefetch" href="/assets/js/9.c8857f5c.js"><link rel="prefetch" href="/assets/js/vuejs-paginate.ff28ef25.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8f4760b9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="global-layout d-flex flex-column"><header id="header" class="shadow"><nav class="p-3 d-flex desktop-menu justify-content-between"><div class="d-flex blog-info-wrapper"><a href="/" class="text-decoration-none m-0 router-link-active"><div class="card-img-bg d-inline-block blog-logo"><img src="https://static.oschina.net/uploads/img/201506/29163716_QJtH.gif" height="70px"></div></a> <a href="/" class="blog-title router-link-active"><div class="h4 text-center">
          yecoding Blog 
        </div></a></div> <ul role="menubar" class="d-flex justify-content-center border-0 el-menu--horizontal el-menu" style="background-color:;"><li role="menuitem" tabindex="-1" router="" class="el-menu-item" style="color:;border-bottom-color:transparent;background-color:;"><i class="el-icon-house"></i>
    Home
  </li><li role="menuitem" tabindex="-1" router="" class="el-menu-item" style="color:;border-bottom-color:transparent;background-color:;"><i class="el-icon-folder"></i>
    Projects
  </li></ul> <div class="search-wrapper u-px3 d-flex align-items-center"><div aria-haspopup="listbox" role="combobox" aria-owns="el-autocomplete-4425" class="el-autocomplete"><div class="el-input el-input--small"><!----><input type="text" autocomplete="off" valueKey="value" popperClass="components-search" placeholder="Search" fetchSuggestions="function () { [native code] }" debounce="200" placement="bottom-end" popperAppendToBody="true" class="el-input__inner"><!----><!----><!----><!----></div><div role="region" class="el-autocomplete-suggestion el-popper components-search" style="width:;display:none;"><div class="el-scrollbar"><div class="el-autocomplete-suggestion__wrap el-scrollbar__wrap el-scrollbar__wrap--hidden-default"><ul class="el-scrollbar__view el-autocomplete-suggestion__list"></ul></div><div class="el-scrollbar__bar is-horizontal"><div class="el-scrollbar__thumb" style="width:0;transform:translateX(0%);ms-transform:translateX(0%);webkit-transform:translateX(0%);"></div></div><div class="el-scrollbar__bar is-vertical"><div class="el-scrollbar__thumb" style="height:0;transform:translateY(0%);ms-transform:translateY(0%);webkit-transform:translateY(0%);"></div></div></div></div></div></div> <div id="toggle"><div id="top" class="span"></div> <div id="middle" class="span"></div> <div id="bottom" class="span"></div></div></nav> <div class="flex-column align-items-center mobile-menu pb-4"><ul role="menubar" class="d-flex justify-content-center border-0 el-menu--horizontal el-menu" style="background-color:;"><li role="menuitem" tabindex="-1" router="" class="el-menu-item" style="color:;border-bottom-color:transparent;background-color:;"><i class="el-icon-house"></i>
    Home
  </li><li role="menuitem" tabindex="-1" router="" class="el-menu-item" style="color:;border-bottom-color:transparent;background-color:;"><i class="el-icon-folder"></i>
    Projects
  </li></ul> <div class="search-wrapper u-px3 d-flex align-items-center pt-4"><div aria-haspopup="listbox" role="combobox" aria-owns="el-autocomplete-3023" class="el-autocomplete"><div class="el-input el-input--small"><!----><input type="text" autocomplete="off" valueKey="value" popperClass="components-search" placeholder="Search" fetchSuggestions="function () { [native code] }" debounce="200" placement="bottom-end" popperAppendToBody="true" class="el-input__inner"><!----><!----><!----><!----></div><div role="region" class="el-autocomplete-suggestion el-popper components-search" style="width:;display:none;"><div class="el-scrollbar"><div class="el-autocomplete-suggestion__wrap el-scrollbar__wrap el-scrollbar__wrap--hidden-default"><ul class="el-scrollbar__view el-autocomplete-suggestion__list"></ul></div><div class="el-scrollbar__bar is-horizontal"><div class="el-scrollbar__thumb" style="width:0;transform:translateX(0%);ms-transform:translateX(0%);webkit-transform:translateX(0%);"></div></div><div class="el-scrollbar__bar is-vertical"><div class="el-scrollbar__thumb" style="height:0;transform:translateY(0%);ms-transform:translateY(0%);webkit-transform:translateY(0%);"></div></div></div></div></div></div></div></header> <div id="vuperess-theme-blog__post-layout"><div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h3 active"><a href="#_1-vue的基本原理" title="1.  Vue的基本原理">1.  Vue的基本原理</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_2-双向数据绑定的原理" title="2.  双向数据绑定的原理">2.  双向数据绑定的原理</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_3-使用-object-defineproperty-来进行数据劫持有什么缺点" title="3. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？">3. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_4-mvvm的理解" title="4. MVVM的理解">4. MVVM的理解</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_5-computed-和-watch-的区别" title="5.  Computed 和 Watch 的区别?">5.  Computed 和 Watch 的区别?</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_6-computed-和-methods-的区别" title="6. Computed 和 Methods 的区别?">6. Computed 和 Methods 的区别?</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_7-slot是什么-有什么作用-原理是什么" title="7.  slot是什么？有什么作用？原理是什么？">7.  slot是什么？有什么作用？原理是什么？</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_8-过滤器的作用-如何实现一个过滤器" title="8.  过滤器的作用，如何实现一个过滤器?">8.  过滤器的作用，如何实现一个过滤器?</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_9-如何保存页面的当前的状态" title="9. 如何保存页面的当前的状态">9. 如何保存页面的当前的状态</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_10-v-if和v-show的区别" title="10.  v-if和v-show的区别？">10.  v-if和v-show的区别？</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_11-data为什么是一个函数而不是对象" title="11. data为什么是一个函数而不是对象?">11. data为什么是一个函数而不是对象?</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_12-nexttick-原理及作用" title="12. $nextTick 原理及作用?">12. $nextTick 原理及作用?</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_13-vue-中给-data-中的对象属性添加一个新的属性时会发生什么-如何解决" title="13.  Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？">13.  Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_14-vue-单页应用与多页应用的区别" title="14.  Vue 单页应用与多页应用的区别?">14.  Vue 单页应用与多页应用的区别?</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_15-vue-data-中某一个属性的值发生改变后-视图会立即同步执行重新渲染吗" title="15. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？">15. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_16-子组件可以直接改变父组件的数据吗" title="16. 子组件可以直接改变父组件的数据吗？">16. 子组件可以直接改变父组件的数据吗？</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_17-对-react-和-vue-的理解-它们的异同" title="17. 对 React 和 Vue 的理解，它们的异同?">17. 对 React 和 Vue 的理解，它们的异同?</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_18-对ssr的理解" title="18. 对SSR的理解">18. 对SSR的理解</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_19-vue的性能优化有哪些" title="19. Vue的性能优化有哪些?">19. Vue的性能优化有哪些?</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_20-对-spa-单页面的理解-它的优缺点分别是什么" title="20. 对 SPA 单页面的理解，它的优缺点分别是什么？">20. 对 SPA 单页面的理解，它的优缺点分别是什么？</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_21、vue初始化页面闪动问题" title="21、vue初始化页面闪动问题">21、vue初始化页面闪动问题</a></div></div> <main class="vuepress-blog-theme-content"><div class="el-card mb-4 is-always-shadow"><!----><div class="el-card__body" style="padding:0;"><img src="http://img.pconline.com.cn/images/upload/upc/tx/itbbs/2003/10/c9/196420048_1583835136058.jpg" alt="前端常见vue面试题(一)" class="w-100"> <div class="p-3"><h1 align="center">
            前端常见vue面试题(一)
          </h1> <div class="ui-post-info d-flex text-secondary d-flex justify-content-center my-3"><div class="post-info-item"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>
    2023年2月16日星期四
  </div> <div class="post-info-item"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>
    4 min read
  </div> <!----></div></div></div></div> <div class="el-card py-3 px-3 mb-4 is-always-shadow"><!----><div class="el-card__body"><span>不登高山，不知天之高也；不临深溪，不知地之厚也</span></div></div> <div class="el-card py-3 px-3 mb-4 is-always-shadow"><!----><div class="el-card__body"><div class="content__default"><h3 id="_1-vue的基本原理"><a href="#_1-vue的基本原理" class="header-anchor">#</a> 1.  Vue的基本原理</h3> <blockquote><p>当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty（vue3.0使用proxy ）将它们转为 getter/setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。
每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依
赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。</p></blockquote> <h3 id="_2-双向数据绑定的原理"><a href="#_2-双向数据绑定的原理" class="header-anchor">#</a> 2.  双向数据绑定的原理</h3> <blockquote><p>Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p></blockquote> <p>主要分为以下几个步骤：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1</span>、需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的
  话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化
<span class="token number">2</span>、compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应
  的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
<span class="token number">3</span>、Watcher订阅者是Observer和Compile之间通信的桥梁，
  <span class="token literal-property property">主要做的事情是</span><span class="token operator">:</span> 
  <span class="token function">①在自身实例化时往属性订阅器</span><span class="token punctuation">(</span>dep<span class="token punctuation">)</span>里面添加自己 
  <span class="token function">②自身必须有一个update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法 
  ③待属性变动dep<span class="token punctuation">.</span><span class="token function">notice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">通知时，能调用自身的update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法，并触发Compile中绑定的回调，则功成身退。
<span class="token number">4</span>、<span class="token constant">MVVM</span>作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己
  的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile
  之间的通信桥梁，达到数据变化 <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token function">视图更新；视图交互变化</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> 数据model变更的双向绑
  定效果。
</code></pre></div><h3 id="_3-使用-object-defineproperty-来进行数据劫持有什么缺点"><a href="#_3-使用-object-defineproperty-来进行数据劫持有什么缺点" class="header-anchor">#</a> 3. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？</h3> <blockquote><p>在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。</p></blockquote> <blockquote><p>在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。</p></blockquote> <h3 id="_4-mvvm的理解"><a href="#_4-mvvm的理解" class="header-anchor">#</a> 4. MVVM的理解</h3> <p>MVVM 分为 Model、View、ViewModel：</p> <blockquote><p>Model代表数据模型，数据和业务逻辑都在Model层中定义；</p></blockquote> <blockquote><p>View代表UI视图，负责数据的展示；</p></blockquote> <blockquote><p>ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code>Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数
据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数
据也会在Model中同步。

这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需
要自己操作<span class="token constant">DOM</span>。
</code></pre></div><h3 id="_5-computed-和-watch-的区别"><a href="#_5-computed-和-watch-的区别" class="header-anchor">#</a> 5.  Computed 和 Watch 的区别?</h3> <blockquote><p>computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。</p></blockquote> <blockquote><p>watch 侦听器 : 更多的是观察的作用，无缓存性，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。</p></blockquote> <p>运用场景：</p> <div class="language-js extra-class"><pre class="language-js"><code>当需要进行数值计算<span class="token punctuation">,</span>并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存
特性，避免每次获取值时都要重新计算。

当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操
<span class="token function">作</span> <span class="token punctuation">(</span> 访问一个 <span class="token constant">API</span> <span class="token punctuation">)</span>，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属
性无法做到的
</code></pre></div><p>对于Computed：</p> <blockquote><p>它支持缓存，只有依赖的数据发生了变化，才会重新计算
不支持异步，当Computed中有异步操作时，无法监听数据的变化
computed的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的。
如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed
如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。</p></blockquote> <p>对于Watch:</p> <blockquote><p>它不支持缓存，数据变化时，它就会触发相应的操作
支持异步监听
监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值
当一个属性发生变化时，就需要执行相应的操作
监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个的参数：</p> <blockquote><p>immediate：组件加载立即触发回调函数</p></blockquote></blockquote> <blockquote><blockquote><p>deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。</p></blockquote></blockquote> <blockquote><p>当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch。</p></blockquote> <h3 id="_6-computed-和-methods-的区别"><a href="#_6-computed-和-methods-的区别" class="header-anchor">#</a> 6. Computed 和 Methods 的区别?</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">computed</span><span class="token operator">:</span> 计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值；

<span class="token literal-property property">method</span><span class="token operator">:</span> 调用总会执行该函数。
</code></pre></div><h3 id="_7-slot是什么-有什么作用-原理是什么"><a href="#_7-slot是什么-有什么作用-原理是什么" class="header-anchor">#</a> 7.  slot是什么？有什么作用？原理是什么？</h3> <blockquote><p>slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。slot又分三类，默认插槽，具名插槽和作用域插槽。</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">默认插槽</span><span class="token operator">:</span>又名匿名插槽，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个
匿名插槽。

<span class="token literal-property property">具名插槽</span><span class="token operator">:</span>带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。

<span class="token literal-property property">作用域插槽</span><span class="token operator">:</span>默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是
在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的
数据决定如何渲染该插槽。
</code></pre></div><blockquote><p>实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在vm.$slot中，默认插槽为vm.$slot.default，具名插槽为vm.$slot.xxx，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用$slot中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。</p></blockquote> <h3 id="_8-过滤器的作用-如何实现一个过滤器"><a href="#_8-过滤器的作用-如何实现一个过滤器" class="header-anchor">#</a> 8.  过滤器的作用，如何实现一个过滤器?</h3> <blockquote><p>根据过滤器的名称，过滤器是用来过滤数据的，在Vue中使用<code>filters</code>来过滤数据，<code>filters</code>不会修改数据，而是过滤数据，改变用户看到的输出（计算属性 <code>computed</code> ，方法 <code>methods</code> 都是通过修改数据来处理数据格式的输出显示）。</p></blockquote> <blockquote><p>使用场景：需要格式化数据的情况，比如需要处理时间、价格等数据格式的输出 / 显示。
比如后端返回一个 年月日的日期字符串，前端需要展示为 多少天前 的数据格式，此时就可以用fliters过滤器来处理数据。</p></blockquote> <blockquote><p>过滤器是一个函数，它会把表达式中的值始终当作函数的第一个参数。过滤器用在插值表达式  和 v-bind 表达式 中，然后放在操作符“ | ”后面进行指示。</p></blockquote> <p>例如，在显示金额，给商品价格添加单位：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>li<span class="token operator">&gt;</span>商品价格：<span class="token punctuation">{</span><span class="token punctuation">{</span>item<span class="token punctuation">.</span>price <span class="token operator">|</span> filterPrice<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>

 <span class="token literal-property property">filters</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">filterPrice</span> <span class="token punctuation">(</span><span class="token parameter">price</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> price <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token string">'￥'</span> <span class="token operator">+</span> price<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">'--'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

</code></pre></div><h3 id="_9-如何保存页面的当前的状态"><a href="#_9-如何保存页面的当前的状态" class="header-anchor">#</a> 9. 如何保存页面的当前的状态</h3> <p>既然是要保持页面的状态（其实也就是组件的状态），那么会出现以下两种情况：</p> <p>前组件会被卸载</p> <p>前组件不会被卸载</p> <p>组件会被卸载：</p> <div class="language-js extra-class"><pre class="language-js"><code>（<span class="token number">1</span>）将状态存储在LocalStorage <span class="token operator">/</span> SessionStorage
  只需要在组件即将被销毁的生命周期 componentWillUnmount （react）中在LocalStorage <span class="token operator">/</span>
  SessionStorage 中把当前组件的 state 通过 <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 储存下来就可以了。在这里
  面需要注意的是组件更新状态的时机。
  比如从 <span class="token constant">B</span> 组件跳转到 <span class="token constant">A</span> 组件的时候，<span class="token constant">A</span> 组件需要更新自身的状态。但是如果从别的组件跳转到 <span class="token constant">B</span> 组
  件的时候，实际上是希望 <span class="token constant">B</span> 组件重新渲染的，也就是不要从 Storage 中读取信息。所以需要在 
  Storage 中的状态加入一个 flag 属性，用来控制 <span class="token constant">A</span> 组件是否读取 Storage 中的状态。
优点：

兼容性好，不需要额外库或工具。
简单快捷，基本可以满足大部分需求。

缺点：

状态通过 <span class="token constant">JSON</span> 方法储存（相当于深拷贝），如果状态中有特殊情况（比如 Date 对象、Regexp 对象
等）的时候会得到字符串而不是原来的值。（具体参考用 <span class="token constant">JSON</span> 深拷贝的缺点）

如果 <span class="token constant">B</span> 组件后退或者下一页跳转并不是前组件，那么 flag 判断会失效，导致从其他页面进入 <span class="token constant">A</span> 组件
页面时 <span class="token constant">A</span> 组件会重新读取 Storage，会造成很奇怪的现象
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token number">2</span>）路由传值
通过 react<span class="token operator">-</span>router 的 Link 组件的 prop —— to 可以实现路由间传递参数的效果。
在这里需要用到 state 参数，在 <span class="token constant">B</span> 组件中通过 history<span class="token punctuation">.</span>location<span class="token punctuation">.</span>state 就可以拿到 state 值，保存它。返回 <span class="token constant">A</span> 组件时再次携带 state 达到路由状态保持的效果。
优点：

简单快捷，不会污染 LocalStorage <span class="token operator">/</span> SessionStorage。
可以传递 Date、RegExp 等特殊对象（不用担心 <span class="token constant">JSON</span><span class="token punctuation">.</span>stringify <span class="token operator">/</span> parse 的不足）

缺点：

如果 <span class="token constant">A</span> 组件可以跳转至多个组件，那么在每一个跳转组件内都要写相同的逻辑。
</code></pre></div><p>组件不会被卸载：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1</span>）单页面渲染
要切换的组件作为子组件全屏渲染，父组件中正常储存页面状态。
优点：

代码量少
不需要考虑状态传递过程中的错误

缺点：

增加 <span class="token constant">A</span> 组件维护成本<span class="token punctuation">;</span>需要传入额外的 prop 到 <span class="token constant">B</span> 组件<span class="token punctuation">;</span>无法利用路由定位页面

除此之外，在Vue中，还可以是用keep<span class="token operator">-</span>alive来缓存页面，当组件在keep<span class="token operator">-</span>alive内被切换时组件的
activated、deactivated这两个生命周期钩子函数会被执行被包裹在keep<span class="token operator">-</span>alive中的组件的状态
将会被保留：

<span class="token operator">&lt;</span>keep<span class="token operator">-</span>alive<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>router<span class="token operator">-</span>view v<span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">&quot;$route.meta.keepAlive&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>view<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>kepp<span class="token operator">-</span>alive<span class="token operator">&gt;</span>

router<span class="token punctuation">.</span>js<span class="token operator">:</span>

<span class="token punctuation">{</span>
  <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'xxx'</span><span class="token punctuation">,</span>
  <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'../src/views/xxx.vue'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token literal-property property">meta</span><span class="token operator">:</span><span class="token punctuation">{</span>
    <span class="token literal-property property">keepAlive</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token comment">// 需要被缓存</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre></div><h3 id="_10-v-if和v-show的区别"><a href="#_10-v-if和v-show的区别" class="header-anchor">#</a> 10.  v-if和v-show的区别？</h3> <div class="language-js extra-class"><pre class="language-js"><code>手段：v<span class="token operator">-</span><span class="token keyword">if</span>是动态的向<span class="token constant">DOM</span>树内添加或者删除<span class="token constant">DOM</span>元素；v<span class="token operator">-</span>show是通过设置<span class="token constant">DOM</span>元素的display样式属性
控制显隐；

编译过程：v<span class="token operator">-</span><span class="token keyword">if</span>切换有一个局部编译<span class="token operator">/</span>卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组
件；v<span class="token operator">-</span>show只是简单的基于css切换；

编译条件：v<span class="token operator">-</span><span class="token keyword">if</span>是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编
译<span class="token punctuation">;</span> v<span class="token operator">-</span>show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且<span class="token constant">DOM</span>元素保留；

性能消耗：v<span class="token operator">-</span><span class="token keyword">if</span>有更高的切换消耗；v<span class="token operator">-</span>show有更高的初始渲染消耗；

使用场景：v<span class="token operator">-</span><span class="token keyword">if</span>适合运营条件不大可能改变；v<span class="token operator">-</span>show适合频繁切换。

</code></pre></div><h3 id="_11-data为什么是一个函数而不是对象"><a href="#_11-data为什么是一个函数而不是对象" class="header-anchor">#</a> 11. data为什么是一个函数而不是对象?</h3> <blockquote><p>JavaScript中的对象是引用类型的数据，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化。</p></blockquote> <blockquote><p>而在Vue中，更多的是想要复用组件，那就需要每个组件都有自己的数据，这样组件之间才不会相互干扰。</p></blockquote> <blockquote><p>所以组件的数据不能写成对象的形式，而是要写成函数的形式。数据以函数返回值的形式定义，这样当每次复用组件的时候，就会返回一个新的data，也就是说每个组件都有自己的私有数据空间，它们各自维护自己的数据，不会干扰其他组件的正常运行</p></blockquote> <h3 id="_12-nexttick-原理及作用"><a href="#_12-nexttick-原理及作用" class="header-anchor">#</a> 12. $nextTick 原理及作用?</h3> <p>Vue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。</p> <blockquote><p>nextTick 的核心是利用了如 Promise 、MutationObserver、setImmediate、setTimeout的原生 JavaScript 方法来模拟对应的微/宏任务的实现，本质是为了利用 JavaScript 的这些异步回调任务队列来实现 Vue 框架中自己的异步回调队列。</p></blockquote> <p>nextTick 是典型的将底层 JavaScript 执行原理应用到具体案例中的示例，引入异步更新队列机制的原因∶</p> <div class="language-js extra-class"><pre class="language-js"><code>如果是同步更新，则多次对一个或多个属性赋值，会频繁触发 <span class="token constant">UI</span><span class="token operator">/</span><span class="token constant">DOM</span> 的渲染，可以减少一些无用渲染

同时由于 VirtualDOM 的引入，每一次状态发生变化后，状态变化的信号会发送给组件，组件内部使用
VirtualDOM 进行计算得出需要更新的具体的 <span class="token constant">DOM</span> 节点，然后对 <span class="token constant">DOM</span> 进行更新操作，每次更新状态
后的渲染过程需要更多的计算，而这种无用功也将浪费更多的性能，所以异步渲染变得更加至关重要
</code></pre></div><p>所以，在以下情况下，会用到nextTick：</p> <div class="language-js extra-class"><pre class="language-js"><code>在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的<span class="token constant">DOM</span>结构的时候，这个操作就需要
<span class="token function">方法在nextTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span>的回调函数中。

<span class="token function">在vue生命周期中，如果在created</span><span class="token punctuation">(</span><span class="token punctuation">)</span>钩子进行<span class="token constant">DOM</span><span class="token function">操作，也一定要放在nextTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span>的回调函数中。

<span class="token function">因为在created</span><span class="token punctuation">(</span><span class="token punctuation">)</span>钩子函数中，页面的<span class="token constant">DOM</span>还未渲染，这时候也没办法操作<span class="token constant">DOM</span>，所以，此时如果想要操
作<span class="token constant">DOM</span><span class="token function">，必须将操作的代码放在nextTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span>的回调函数中。
</code></pre></div><h3 id="_13-vue-中给-data-中的对象属性添加一个新的属性时会发生什么-如何解决"><a href="#_13-vue-中给-data-中的对象属性添加一个新的属性时会发生什么-如何解决" class="header-anchor">#</a> 13.  Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>template<span class="token operator">&gt;</span> 
   <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span>
         <span class="token operator">&lt;</span>li v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">&quot;value in obj&quot;</span> <span class="token operator">:</span>key<span class="token operator">=</span><span class="token string">&quot;value&quot;</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>value<span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span> 
      <span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span> 
      <span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">&quot;addObjB&quot;</span><span class="token operator">&gt;</span>添加 obj<span class="token punctuation">.</span>b<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span> 
   <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
    <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span> 
       <span class="token function">data</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
          <span class="token keyword">return</span> <span class="token punctuation">{</span> 
              <span class="token literal-property property">obj</span><span class="token operator">:</span> <span class="token punctuation">{</span> 
                  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token string">'obj.a'</span> 
              <span class="token punctuation">}</span> 
          <span class="token punctuation">}</span> 
       <span class="token punctuation">}</span><span class="token punctuation">,</span>
       <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span> 
          <span class="token function">addObjB</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
              <span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token string">'obj.b'</span> 
              console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">)</span> 
          <span class="token punctuation">}</span> 
      <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div><p>点击 button 会发现，obj.b 已经成功添加，但是视图并未刷新。这是因为在Vue实例创建时，obj.b并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局 api $set()：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">addObjB</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>
   <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'obj.b'</span><span class="token punctuation">)</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>$set()方法相当于手动的去把obj.b处理成一个响应式的属性，此时视图也会跟着改变了</p></blockquote> <h3 id="_14-vue-单页应用与多页应用的区别"><a href="#_14-vue-单页应用与多页应用的区别" class="header-anchor">#</a> 14.  Vue 单页应用与多页应用的区别?</h3> <p>概念：</p> <blockquote><p>SPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。</p></blockquote> <blockquote><p>MPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新</p></blockquote> <h3 id="_15-vue-data-中某一个属性的值发生改变后-视图会立即同步执行重新渲染吗"><a href="#_15-vue-data-中某一个属性的值发生改变后-视图会立即同步执行重新渲染吗" class="header-anchor">#</a> 15. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？</h3> <blockquote><p>不会立即同步执行重新渲染。Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。</p></blockquote> <blockquote><p>如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环tick中，Vue 刷新队列并执行实际（已去重的）工作。</p></blockquote> <h3 id="_16-子组件可以直接改变父组件的数据吗"><a href="#_16-子组件可以直接改变父组件的数据吗" class="header-anchor">#</a> 16. 子组件可以直接改变父组件的数据吗？</h3> <blockquote><p>子组件不可以直接改变父组件的数据。这样做主要是为了维护父子组件的单向数据流。每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。如果这样做了，Vue 会在浏览器的控制台中发出警告。</p></blockquote> <blockquote><p>Vue提倡单向数据流，即父级 props 的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。</p></blockquote> <p><strong>只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</strong></p> <h3 id="_17-对-react-和-vue-的理解-它们的异同"><a href="#_17-对-react-和-vue-的理解-它们的异同" class="header-anchor">#</a> 17. 对 React 和 Vue 的理解，它们的异同?</h3> <p>相似之处：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库；
都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板；
都使用了Virtual DOM（虚拟DOM）提高重绘性能；
都有props的概念，允许组件间的数据传递；
都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性。
</code></pre></div><p>不同之处 ：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1</span>）数据流
Vue默认支持数据双向绑定，而React一直提倡单向数据流
<span class="token number">2</span>）虚拟<span class="token constant">DOM</span>
Vue2<span class="token punctuation">.</span>x开始引入<span class="token string">&quot;Virtual DOM&quot;</span>，消除了和React在这方面的差异，但是在具体的细节还是有各自的特
点。

Vue宣称可以更快地计算出Virtual <span class="token constant">DOM</span>的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关
系，不需要重新渲染整个组件树。

对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 
PureComponent<span class="token operator">/</span>shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优
化。

<span class="token number">3</span>）组件化
React与Vue最大的不同是模板的编写。

Vue鼓励写近似常规<span class="token constant">HTML</span>的模板。写起来很接近标准 <span class="token constant">HTML</span>元素，只是多了一些属性。
React推荐你所有的模板通用JavaScript的语法扩展——<span class="token constant">JSX</span>书写。

具体来讲：React中render函数是支持闭包特性的，所以<span class="token keyword">import</span>的组件在render中可以直接调用。但是
在Vue中，由于模板中使用的数据都必须挂在 <span class="token keyword">this</span> 上进行一次中转，所以 <span class="token keyword">import</span> 一个组件完了之
后，还需要在 components 中再声明下。
<span class="token number">4</span>）监听数据变化的实现原理不同

Vue 通过 getter<span class="token operator">/</span>setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很
好的性能

React 默认是通过比较引用的方式进行的，如果不优化（PureComponent<span class="token operator">/</span>
shouldComponentUpdate）可能导致大量不必要的vDOM的重新渲染。这是因为 Vue 使用的是可变数
据，而React更强调数据的不可变。

<span class="token number">5</span>）高阶组件
react可以通过高阶组件（<span class="token constant">HOC</span>）来扩展，而Vue需要通过mixins来扩展。
高阶组件就是高阶函数，而React的组件本身就是纯粹的函数，所以高阶函数对React来说易如反掌。
相反Vue<span class="token punctuation">.</span>js使用<span class="token constant">HTML</span>模板创建视图组件，这时模板无法有效的编译，因此Vue不能采用<span class="token constant">HOC</span>来实现。
<span class="token number">6</span>）构建工具
两者都有自己的构建工具：

React <span class="token operator">==</span><span class="token operator">&gt;</span> Create React <span class="token constant">APP</span>

Vue <span class="token operator">==</span><span class="token operator">&gt;</span> vue<span class="token operator">-</span>cli

<span class="token number">7</span>）跨平台

React <span class="token operator">==</span><span class="token operator">&gt;</span> React Native

Vue <span class="token operator">==</span><span class="token operator">&gt;</span> Weex
</code></pre></div><h3 id="_18-对ssr的理解"><a href="#_18-对ssr的理解" class="header-anchor">#</a> 18. 对SSR的理解</h3> <p>SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html
直接返回给客户端.</p> <p>SSR的优势：</p> <div class="language-js extra-class"><pre class="language-js"><code>更好的<span class="token constant">SEO</span>

首屏加载速度更快
</code></pre></div><p>SSR的缺点：</p> <div class="language-js extra-class"><pre class="language-js"><code>开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子；

当需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node<span class="token punctuation">.</span>js的运行环境；

更多的服务端负载。
</code></pre></div><h3 id="_19-vue的性能优化有哪些"><a href="#_19-vue的性能优化有哪些" class="header-anchor">#</a> 19. Vue的性能优化有哪些?</h3> <p>（1）编码阶段</p> <div class="language-js extra-class"><pre class="language-js"><code>尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher
v<span class="token operator">-</span><span class="token keyword">if</span>和v<span class="token operator">-</span><span class="token keyword">for</span>不能连用
如果需要使用v<span class="token operator">-</span><span class="token keyword">for</span>给每项元素绑定事件时使用事件代理
<span class="token constant">SPA</span> 页面采用keep<span class="token operator">-</span>alive缓存组件
在更多的情况下，使用v<span class="token operator">-</span><span class="token keyword">if</span>替代v<span class="token operator">-</span>show
key保证唯一
使用路由懒加载、异步组件
防抖、节流
第三方模块按需导入
长列表滚动到可视区域动态加载
图片懒加载
</code></pre></div><p>（2）SEO优化</p> <div class="language-js extra-class"><pre class="language-js"><code>预渲染
服务端渲染<span class="token constant">SSR</span>
</code></pre></div><p>（3）打包优化</p> <div class="language-js extra-class"><pre class="language-js"><code>压缩代码
Tree Shaking<span class="token operator">/</span>Scope Hoisting
使用cdn加载第三方模块
多线程打包happypack
splitChunks抽离公共文件
sourceMap优化
</code></pre></div><p>（4）用户体验</p> <div class="language-js extra-class"><pre class="language-js"><code>骨架屏
<span class="token constant">PWA</span>
<span class="token function">还可以使用缓存</span><span class="token punctuation">(</span>客户端缓存、服务端缓存<span class="token punctuation">)</span>优化、服务端开启gzip压缩等。
</code></pre></div><h3 id="_20-对-spa-单页面的理解-它的优缺点分别是什么"><a href="#_20-对-spa-单页面的理解-它的优缺点分别是什么" class="header-anchor">#</a> 20. 对 SPA 单页面的理解，它的优缺点分别是什么？</h3> <blockquote><p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p></blockquote> <p><strong>优点：</strong></p> <div class="language-js extra-class"><pre class="language-js"><code>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
基于上面一点，<span class="token constant">SPA</span> 相对对服务器压力小；
前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；
</code></pre></div><p><strong>缺点：</strong></p> <div class="language-js extra-class"><pre class="language-js"><code>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、
<span class="token constant">CSS</span> 统一加载，部分页面按需加载；

前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，
所有的页面切换需要自己建立堆栈管理；

<span class="token constant">SEO</span> 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 <span class="token constant">SEO</span> 上其有着天然的弱势。
</code></pre></div><h3 id="_21、vue初始化页面闪动问题"><a href="#_21、vue初始化页面闪动问题" class="header-anchor">#</a> 21、vue初始化页面闪动问题</h3> <blockquote><p>使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于的字样，虽然一般情况下这个时间很短暂，但是还是有必要让解决这个问题的。</p></blockquote> <p>首先：在css里加上以下代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">[</span>v<span class="token operator">-</span>cloak<span class="token punctuation">]</span> <span class="token punctuation">{</span>    <span class="token literal-property property">display</span><span class="token operator">:</span> none<span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre></div><p>如果没有彻底解决问题，则在根元素加上style=&quot;display: none;&quot; :style=&quot;{display: 'block'}&quot;</p></div></div></div> <div class="el-card py-3 px-3 mb-4 is-always-shadow"><!----><div class="el-card__body"><span>时人不识临云木，直待凌云道始高</span></div></div> <div class="el-card mb-4 is-always-shadow"><div class="el-card__header"><div class="clearfix"><h5 class="m-0">
            Read more
          </h5></div></div><div class="el-card__body"> <div class="container featured-posts my-4"><div class="el-carousel el-carousel--horizontal el-carousel--card"><div class="el-carousel__container" style="height:300px;"><button type="button" class="el-carousel__arrow el-carousel__arrow--left" style="display:none;"><i class="el-icon-arrow-left"></i></button><button type="button" class="el-carousel__arrow el-carousel__arrow--right" style="display:none;"><i class="el-icon-arrow-right"></i></button><div class="el-carousel__item carousel-card bg-cover border-10 el-carousel__item--card" style="transform:translateX(0px) scale(1);ms-transform:translateX(0px) scale(1);webkit-transform:translateX(0px) scale(1);display:none;background-image:url(https://img.zcool.cn/community/01f9fc5c432d69a801203d22d4b81a.jpg@1280w_1l_2o_100sh.jpg);background-blend-mode:multiply;background-size:cover;background-color:rgba(0,0,0,0.3);"><div class="el-carousel__mask"></div><div class="carousel-card-content d-flex justify-content-center align-items-center flex-column h-100"><h4 class="story-title text-center h4 mb-3 text-light">
          JavaScript基础问题(一)
        </h4> <a href="/2023/02/13/js%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-01/" class="el-button el-button--primary">
          Read this Post <i class="el-icon-arrow-right"></i></a></div></div><div class="el-carousel__item carousel-card bg-cover border-10 el-carousel__item--card" style="transform:translateX(0px) scale(1);ms-transform:translateX(0px) scale(1);webkit-transform:translateX(0px) scale(1);display:none;background-image:url(https://www.2008php.com/2011_Website_appreciate/2011-09-23/20110923163645.jpg);background-blend-mode:multiply;background-size:cover;background-color:rgba(0,0,0,0.3);"><div class="el-carousel__mask"></div><div class="carousel-card-content d-flex justify-content-center align-items-center flex-column h-100"><h4 class="story-title text-center h4 mb-3 text-light">
          JavaScript基础问题(二)
        </h4> <a href="/2023/02/14/js%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-02/" class="el-button el-button--primary">
          Read this Post <i class="el-icon-arrow-right"></i></a></div></div><div class="el-carousel__item carousel-card bg-cover border-10 el-carousel__item--card" style="transform:translateX(0px) scale(1);ms-transform:translateX(0px) scale(1);webkit-transform:translateX(0px) scale(1);display:none;background-image:url(https://i.picsum.photos/id/79/800/600.jpg);background-blend-mode:multiply;background-size:cover;background-color:rgba(0,0,0,0.3);"><div class="el-carousel__mask"></div><div class="carousel-card-content d-flex justify-content-center align-items-center flex-column h-100"><h4 class="story-title text-center h4 mb-3 text-light">
          Create a modern vuepress blog in 5 minutes!
        </h4> <a href="/2019/10/14/vuepress-modern-blog-theme/" class="el-button el-button--primary">
          Read this Post <i class="el-icon-arrow-right"></i></a></div></div><div class="el-carousel__item carousel-card bg-cover border-10 el-carousel__item--card" style="transform:translateX(0px) scale(1);ms-transform:translateX(0px) scale(1);webkit-transform:translateX(0px) scale(1);display:none;background-image:url(https://img.zcool.cn/community/01cf6858635528a8012060c8b33f77.jpg@1280w_1l_2o_100sh.jpg);background-blend-mode:multiply;background-size:cover;background-color:rgba(0,0,0,0.3);"><div class="el-carousel__mask"></div><div class="carousel-card-content d-flex justify-content-center align-items-center flex-column h-100"><h4 class="story-title text-center h4 mb-3 text-light">
          前端常见面试题
        </h4> <a href="/2023/02/15/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-03/" class="el-button el-button--primary">
          Read this Post <i class="el-icon-arrow-right"></i></a></div></div><div class="el-carousel__item carousel-card bg-cover border-10 el-carousel__item--card" style="transform:translateX(0px) scale(1);ms-transform:translateX(0px) scale(1);webkit-transform:translateX(0px) scale(1);display:none;background-image:url(http://pic.bizhi360.com/bbpic/76/5776.jpg);background-blend-mode:multiply;background-size:cover;background-color:rgba(0,0,0,0.3);"><div class="el-carousel__mask"></div><div class="carousel-card-content d-flex justify-content-center align-items-center flex-column h-100"><h4 class="story-title text-center h4 mb-3 text-light">
          前端常见vue面试题(二)
        </h4> <a href="/2023/02/16/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98vue-05/" class="el-button el-button--primary">
          Read this Post <i class="el-icon-arrow-right"></i></a></div></div><div class="el-carousel__item carousel-card bg-cover border-10 el-carousel__item--card" style="transform:translateX(0px) scale(1);ms-transform:translateX(0px) scale(1);webkit-transform:translateX(0px) scale(1);display:none;background-image:url(http://img.pconline.com.cn/images/upload/upc/tx/itbbs/2003/10/c9/196420048_1583835136058.jpg);background-blend-mode:multiply;background-size:cover;background-color:rgba(0,0,0,0.3);"><div class="el-carousel__mask"></div><div class="carousel-card-content d-flex justify-content-center align-items-center flex-column h-100"><h4 class="story-title text-center h4 mb-3 text-light">
          前端常见vue面试题(一)
        </h4> <a href="/2023/02/16/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98vue-04/" aria-current="page" class="el-button el-button--primary router-link-exact-active router-link-active">
          Read this Post <i class="el-icon-arrow-right"></i></a></div></div><div class="el-carousel__item carousel-card bg-cover border-10 el-carousel__item--card" style="transform:translateX(0px) scale(1);ms-transform:translateX(0px) scale(1);webkit-transform:translateX(0px) scale(1);display:none;background-image:url(http://up.deskcity.org/pic_source/d6/a6/3c/d6a63c350c8ea49404a71face8f969b5.jpg);background-blend-mode:multiply;background-size:cover;background-color:rgba(0,0,0,0.3);"><div class="el-carousel__mask"></div><div class="carousel-card-content d-flex justify-content-center align-items-center flex-column h-100"><h4 class="story-title text-center h4 mb-3 text-light">
          前端常见vue3面试题(三)
        </h4> <a href="/2023/02/16/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98vue3-06/" class="el-button el-button--primary">
          Read this Post <i class="el-icon-arrow-right"></i></a></div></div></div><ul class="el-carousel__indicators el-carousel__indicators--horizontal el-carousel__indicators--outside"></ul></div></div></div></div> <div class="el-card is-always-shadow"><div class="el-card__header"><div class="clearfix"><h5 class="m-0">
            Tags
          </h5></div></div><div class="el-card__body"> <div><a href="/tag/vue" class="el-button el-button--small text-decoration-none d-inline-block mb-3">
            #vue
          </a><a href="/tag/面试题" class="el-button el-button--small text-decoration-none d-inline-block mb-3">
            #面试题
          </a></div></div></div> <!----></main></div> <footer class="footer" data-v-85a2b3d2><div class="footer-left-wrap" data-v-85a2b3d2><ul class="contact" data-v-85a2b3d2><li class="contact-item" data-v-85a2b3d2><a href="https://github.com/yeCodings" target="_blank" rel="noopener noreferrer" class="external" data-v-85a2b3d2><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github" data-v-85a2b3d2><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" data-v-85a2b3d2></path></svg>
          
        </a></li><li class="contact-item" data-v-85a2b3d2><a href="https://instagram.com" target="_blank" rel="noopener noreferrer" class="external" data-v-85a2b3d2><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-instagram" data-v-85a2b3d2><rect x="2" y="2" width="20" height="20" rx="5" ry="5" data-v-85a2b3d2></rect><path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z" data-v-85a2b3d2></path><line x1="17.5" y1="6.5" x2="17.5" y2="6.5" data-v-85a2b3d2></line></svg>
          
        </a></li><li class="contact-item" data-v-85a2b3d2><a href="https://linkedin.com" target="_blank" rel="noopener noreferrer" class="external" data-v-85a2b3d2><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-linkedin" data-v-85a2b3d2><path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z" data-v-85a2b3d2></path><rect x="2" y="9" width="4" height="12" data-v-85a2b3d2></rect><circle cx="4" cy="4" r="2" data-v-85a2b3d2></circle></svg>
          
        </a></li><li class="contact-item" data-v-85a2b3d2><a href="https://twitter.com" target="_blank" rel="noopener noreferrer" class="external" data-v-85a2b3d2><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-twitter" data-v-85a2b3d2><path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z" data-v-85a2b3d2></path></svg>
          
        </a></li></ul></div> <div class="footer-right-wrap" data-v-85a2b3d2><ul class="copyright" data-v-85a2b3d2><li class="copyright-item" data-v-85a2b3d2><a data-v-85a2b3d2>MIT Licensed | Copyright © 2018-present Vue.js</a></li></ul></div></footer> <!----></div><div class="global-ui"><!----><div class="Sakura" data-v-248d85d6><canvas id="canvas_sakura" style="z-index:-1;" data-v-248d85d6></canvas></div></div></div>
    <script src="/assets/js/app.910dc115.js" defer></script><script src="/assets/js/4.5b8d8b22.js" defer></script><script src="/assets/js/17.b3c10cd1.js" defer></script><script src="/assets/js/6.d2ea23d8.js" defer></script>
  </body>
</html>

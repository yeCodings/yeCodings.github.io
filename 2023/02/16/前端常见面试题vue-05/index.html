<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端常见vue面试题(二) | yecoding Blog </title>
    <meta name="generator" content="VuePress 1.9.8">
    
    <meta name="description" content="This is a blog example built by VuePress">
    
    <link rel="preload" href="/assets/css/0.styles.8f4760b9.css" as="style"><link rel="preload" href="/assets/js/app.910dc115.js" as="script"><link rel="preload" href="/assets/js/4.5b8d8b22.js" as="script"><link rel="preload" href="/assets/js/18.6e7e20b1.js" as="script"><link rel="preload" href="/assets/js/6.d2ea23d8.js" as="script"><link rel="prefetch" href="/assets/js/10.dcbecad9.js"><link rel="prefetch" href="/assets/js/11.bc878eb5.js"><link rel="prefetch" href="/assets/js/12.7ad4a89b.js"><link rel="prefetch" href="/assets/js/13.c961a1cb.js"><link rel="prefetch" href="/assets/js/14.95c14d5f.js"><link rel="prefetch" href="/assets/js/15.554403c9.js"><link rel="prefetch" href="/assets/js/16.08abd0f0.js"><link rel="prefetch" href="/assets/js/17.b3c10cd1.js"><link rel="prefetch" href="/assets/js/19.d462b7fe.js"><link rel="prefetch" href="/assets/js/20.6f403a75.js"><link rel="prefetch" href="/assets/js/21.8a262424.js"><link rel="prefetch" href="/assets/js/22.c0bf7021.js"><link rel="prefetch" href="/assets/js/23.243528c8.js"><link rel="prefetch" href="/assets/js/3.70520c45.js"><link rel="prefetch" href="/assets/js/5.9cf19b34.js"><link rel="prefetch" href="/assets/js/7.b101bcbb.js"><link rel="prefetch" href="/assets/js/8.ab8a61c9.js"><link rel="prefetch" href="/assets/js/9.c8857f5c.js"><link rel="prefetch" href="/assets/js/vuejs-paginate.ff28ef25.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8f4760b9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="global-layout d-flex flex-column"><header id="header" class="shadow"><nav class="p-3 d-flex desktop-menu justify-content-between"><div class="d-flex blog-info-wrapper"><a href="/" class="text-decoration-none m-0 router-link-active"><div class="card-img-bg d-inline-block blog-logo"><img src="https://static.oschina.net/uploads/img/201506/29163716_QJtH.gif" height="70px"></div></a> <a href="/" class="blog-title router-link-active"><div class="h4 text-center">
          yecoding Blog 
        </div></a></div> <ul role="menubar" class="d-flex justify-content-center border-0 el-menu--horizontal el-menu" style="background-color:;"><li role="menuitem" tabindex="-1" router="" class="el-menu-item" style="color:;border-bottom-color:transparent;background-color:;"><i class="el-icon-house"></i>
    Home
  </li><li role="menuitem" tabindex="-1" router="" class="el-menu-item" style="color:;border-bottom-color:transparent;background-color:;"><i class="el-icon-folder"></i>
    Projects
  </li></ul> <div class="search-wrapper u-px3 d-flex align-items-center"><div aria-haspopup="listbox" role="combobox" aria-owns="el-autocomplete-6358" class="el-autocomplete"><div class="el-input el-input--small"><!----><input type="text" autocomplete="off" valueKey="value" popperClass="components-search" placeholder="Search" fetchSuggestions="function () { [native code] }" debounce="200" placement="bottom-end" popperAppendToBody="true" class="el-input__inner"><!----><!----><!----><!----></div><div role="region" class="el-autocomplete-suggestion el-popper components-search" style="width:;display:none;"><div class="el-scrollbar"><div class="el-autocomplete-suggestion__wrap el-scrollbar__wrap el-scrollbar__wrap--hidden-default"><ul class="el-scrollbar__view el-autocomplete-suggestion__list"></ul></div><div class="el-scrollbar__bar is-horizontal"><div class="el-scrollbar__thumb" style="width:0;transform:translateX(0%);ms-transform:translateX(0%);webkit-transform:translateX(0%);"></div></div><div class="el-scrollbar__bar is-vertical"><div class="el-scrollbar__thumb" style="height:0;transform:translateY(0%);ms-transform:translateY(0%);webkit-transform:translateY(0%);"></div></div></div></div></div></div> <div id="toggle"><div id="top" class="span"></div> <div id="middle" class="span"></div> <div id="bottom" class="span"></div></div></nav> <div class="flex-column align-items-center mobile-menu pb-4"><ul role="menubar" class="d-flex justify-content-center border-0 el-menu--horizontal el-menu" style="background-color:;"><li role="menuitem" tabindex="-1" router="" class="el-menu-item" style="color:;border-bottom-color:transparent;background-color:;"><i class="el-icon-house"></i>
    Home
  </li><li role="menuitem" tabindex="-1" router="" class="el-menu-item" style="color:;border-bottom-color:transparent;background-color:;"><i class="el-icon-folder"></i>
    Projects
  </li></ul> <div class="search-wrapper u-px3 d-flex align-items-center pt-4"><div aria-haspopup="listbox" role="combobox" aria-owns="el-autocomplete-9137" class="el-autocomplete"><div class="el-input el-input--small"><!----><input type="text" autocomplete="off" valueKey="value" popperClass="components-search" placeholder="Search" fetchSuggestions="function () { [native code] }" debounce="200" placement="bottom-end" popperAppendToBody="true" class="el-input__inner"><!----><!----><!----><!----></div><div role="region" class="el-autocomplete-suggestion el-popper components-search" style="width:;display:none;"><div class="el-scrollbar"><div class="el-autocomplete-suggestion__wrap el-scrollbar__wrap el-scrollbar__wrap--hidden-default"><ul class="el-scrollbar__view el-autocomplete-suggestion__list"></ul></div><div class="el-scrollbar__bar is-horizontal"><div class="el-scrollbar__thumb" style="width:0;transform:translateX(0%);ms-transform:translateX(0%);webkit-transform:translateX(0%);"></div></div><div class="el-scrollbar__bar is-vertical"><div class="el-scrollbar__thumb" style="height:0;transform:translateY(0%);ms-transform:translateY(0%);webkit-transform:translateY(0%);"></div></div></div></div></div></div></div></header> <div id="vuperess-theme-blog__post-layout"><div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h3 active"><a href="#_1、mvvm的优缺点" title="1、MVVM的优缺点?">1、MVVM的优缺点?</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_2、-说一下vue的生命周期" title="2、 说一下Vue的生命周期">2、 说一下Vue的生命周期</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_3、vue-子组件和父组件执行顺序" title="3、Vue 子组件和父组件执行顺序">3、Vue 子组件和父组件执行顺序</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_4、-created和mounted的区别" title="4、 created和mounted的区别">4、 created和mounted的区别</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_5、一般在哪个生命周期请求异步数据" title="5、一般在哪个生命周期请求异步数据">5、一般在哪个生命周期请求异步数据</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_6、keep-alive-中的生命周期哪些" title="6、keep-alive 中的生命周期哪些？">6、keep-alive 中的生命周期哪些？</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_7、-组件通信" title="7、 组件通信">7、 组件通信</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_8、-vue-router-的懒加载如何实现" title="8、 Vue-Router 的懒加载如何实现">8、 Vue-Router 的懒加载如何实现</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_9、-路由的hash和history模式的区别" title="9、 路由的hash和history模式的区别？">9、 路由的hash和history模式的区别？</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_10、-如何获取页面的hash变化" title="10、 如何获取页面的hash变化？">10、 如何获取页面的hash变化？</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_11、-route-和-router-的区别" title="11、$route 和$router 的区别?">11、$route 和$router 的区别?</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_12、如何定义动态路由-如何获取传过来的动态参数" title="12、如何定义动态路由？如何获取传过来的动态参数？">12、如何定义动态路由？如何获取传过来的动态参数？</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_13、-vue-router-路由钩子在生命周期的体现" title="13、 Vue-router 路由钩子在生命周期的体现">13、 Vue-router 路由钩子在生命周期的体现</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_14、vue-router跳转和location-href有什么区别" title="14、Vue-router跳转和location.href有什么区别?">14、Vue-router跳转和location.href有什么区别?</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_15、-params和query的区别" title="15、 params和query的区别?">15、 params和query的区别?</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_16、-vue-router-导航守卫有哪些" title="16、 Vue-router 导航守卫有哪些">16、 Vue-router 导航守卫有哪些</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_17、-vuex-的原理" title="17、 Vuex 的原理">17、 Vuex 的原理</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_18、vuex中action和mutation的区别" title="18、Vuex中action和mutation的区别">18、Vuex中action和mutation的区别</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_19、redux-和-vuex-有什么区别-它们的共同思想" title="19、Redux 和 Vuex 有什么区别，它们的共同思想">19、Redux 和 Vuex 有什么区别，它们的共同思想</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_20、-vuex有哪几种属性" title="20、 Vuex有哪几种属性？">20、 Vuex有哪几种属性？</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_21、为什么-vuex-的-mutation-中不能做异步操作" title="21、为什么 Vuex 的 mutation 中不能做异步操作？">21、为什么 Vuex 的 mutation 中不能做异步操作？</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_22、如何在组件中批量使用vuex的getter属性" title="22、如何在组件中批量使用Vuex的getter属性？">22、如何在组件中批量使用Vuex的getter属性？</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_23、如何在组件中重复使用vuex的mutation" title="23、如何在组件中重复使用Vuex的mutation？">23、如何在组件中重复使用Vuex的mutation？</a></div></div> <main class="vuepress-blog-theme-content"><div class="el-card mb-4 is-always-shadow"><!----><div class="el-card__body" style="padding:0;"><img src="http://pic.bizhi360.com/bbpic/76/5776.jpg" alt="前端常见vue面试题(二)" class="w-100"> <div class="p-3"><h1 align="center">
            前端常见vue面试题(二)
          </h1> <div class="ui-post-info d-flex text-secondary d-flex justify-content-center my-3"><div class="post-info-item"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>
    2023年2月16日星期四
  </div> <div class="post-info-item"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>
    6 min read
  </div> <!----></div></div></div></div> <div class="el-card py-3 px-3 mb-4 is-always-shadow"><!----><div class="el-card__body"><span>不登高山，不知天之高也；不临深溪，不知地之厚也</span></div></div> <div class="el-card py-3 px-3 mb-4 is-always-shadow"><!----><div class="el-card__body"><div class="content__default"><h3 id="_1、mvvm的优缺点"><a href="#_1、mvvm的优缺点" class="header-anchor">#</a> 1、MVVM的优缺点?</h3> <p><strong>优点:</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">分离视图（View）和模型（Model），降低代码耦合，提⾼视图或者逻辑的重⽤性</span><span class="token operator">:</span> ⽐如视图（View）
可以独⽴于Model变化和修改，⼀个ViewModel可以绑定不同的<span class="token string">&quot;View&quot;</span>上，当View变化的时候Model不
可以不变，当Model变化的时候View也可以不变。你可以把⼀些视图逻辑放在⼀个ViewModel⾥⾯，让很
多view重⽤这段视图逻辑

<span class="token literal-property property">提⾼可测试性</span><span class="token operator">:</span> ViewModel的存在可以帮助开发者更好地编写测试代码

<span class="token literal-property property">⾃动更新dom</span><span class="token operator">:</span> 利⽤双向绑定<span class="token punctuation">,</span>数据更新后视图⾃动更新<span class="token punctuation">,</span>让开发者从繁琐的⼿动dom中解放
</code></pre></div><p><strong>缺点:</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">Bug很难被调试</span><span class="token operator">:</span> 因为使⽤双向绑定的模式，当你看到界⾯异常了，有可能是你View的代码有Bug，也可
能是Model的代码有问题。数据绑定使得⼀个位置的Bug被快速传递到别的位置，要定位原始出问题的地⽅
就变得不那么容易了。另外，数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打
断点debug的

⼀个⼤的模块中model也会很⼤，虽然使⽤⽅便了也很容易保证了数据的⼀致性，当时⻓期持有，不释放
内存就造成了花费更多的内存

对于⼤型的图形应⽤程序，视图状态较多，ViewModel的构建和维护的成本都会⽐较⾼。
</code></pre></div><h3 id="_2、-说一下vue的生命周期"><a href="#_2、-说一下vue的生命周期" class="header-anchor">#</a> 2、 说一下Vue的生命周期</h3> <p><strong>Vue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -&gt; 渲染、更新 -&gt; 渲染、卸载 等⼀系列过程，称这是Vue的⽣命周期。</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1</span>、beforeCreate（创建前）：数据观测和初始化事件还未开始，此时 data 的响应式追踪、event<span class="token operator">/</span>
watcher 都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数
据。

<span class="token number">2</span>、created（创建后） ：实例创建完成，实例上配置的 options 包括 data、computed、watch、
methods 等都配置完成，但是此时渲染得节点还未挂载到 <span class="token constant">DOM</span>，所以不能访问到 $el 属性。

<span class="token number">3</span>、beforeMount（挂载前）：在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下
的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上。

<span class="token number">4</span>、mounted（挂载后）：在el被新创建的 vm<span class="token punctuation">.</span>$el 替换，并挂载到实例上去之后调用。实例已完成以下
的配置：用上面编译好的html内容替换el属性指向的<span class="token constant">DOM</span>对象。完成模板中的html渲染到html 页面中。
此过程中进行ajax交互。

<span class="token number">5</span>、beforeUpdate（更新前）：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 
<span class="token constant">DOM</span> 还没有被渲染。

<span class="token number">6</span>、updated（更新后） ：在由于数据更改导致的虚拟<span class="token constant">DOM</span>重新渲染和打补丁之后调用。此时 <span class="token constant">DOM</span> 已经
根据响应式数据的变化更新了。调用时，组件 <span class="token constant">DOM</span>已经更新，所以可以执行依赖于<span class="token constant">DOM</span>的操作。然而在大
多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间
不被调用。

<span class="token number">7</span>、beforeDestroy（销毁前）：实例销毁之前调用。这一步，实例仍然完全可用，<span class="token keyword">this</span> 仍能获取到实例。

<span class="token number">8</span>、destroyed（销毁后）：实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事
件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。
</code></pre></div><blockquote><p>另外还有 <code>keep-alive</code>独有的生命周期，分别为 <code>activated</code> <code>和 deactivated</code> 。用 <code>keep-alive</code> 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 <code>deactivated</code> 钩子函数，命中缓存渲染后会执行 <code>activated</code> 钩子函数。</p></blockquote> <h3 id="_3、vue-子组件和父组件执行顺序"><a href="#_3、vue-子组件和父组件执行顺序" class="header-anchor">#</a> 3、Vue 子组件和父组件执行顺序</h3> <p><strong>加载渲染过程：</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1</span>、父组件 beforeCreate
<span class="token number">2</span>、父组件 created
<span class="token number">3</span>、父组件 beforeMount
<span class="token number">4</span>、子组件 beforeCreate
<span class="token number">5</span>、子组件 created
<span class="token number">6</span>、子组件 beforeMount
<span class="token number">7</span>、子组件 mounted
<span class="token number">8</span>、父组件 mounted
</code></pre></div><p><strong>更新过程：</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1</span>、父组件 beforeUpdate
<span class="token number">2</span>、子组件 beforeUpdate
<span class="token number">3</span>、子组件 updated
<span class="token number">4</span>、父组件 updated
</code></pre></div><p><strong>销毁过程：</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1</span>、父组件 beforeDestroy
<span class="token number">2</span>、子组件 beforeDestroy
<span class="token number">3</span>、子组件 destroyed
<span class="token number">4</span>、父组件 destoryed
</code></pre></div><h3 id="_4、-created和mounted的区别"><a href="#_4、-created和mounted的区别" class="header-anchor">#</a> 4、 created和mounted的区别</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">created</span><span class="token operator">:</span>在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。

<span class="token literal-property property">mounted</span><span class="token operator">:</span>在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作
</code></pre></div><h3 id="_5、一般在哪个生命周期请求异步数据"><a href="#_5、一般在哪个生命周期请求异步数据" class="header-anchor">#</a> 5、一般在哪个生命周期请求异步数据</h3> <blockquote><p>我们可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。</p></blockquote> <p><strong>推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点</strong>​</p> <div class="language-js extra-class"><pre class="language-js"><code>能更快获取到服务端数据，减少页面加载时间，用户体验更好；

<span class="token constant">SSR</span>不支持 beforeMount 、mounted 钩子函数，放在 created 中有助于一致性。
</code></pre></div><h3 id="_6、keep-alive-中的生命周期哪些"><a href="#_6、keep-alive-中的生命周期哪些" class="header-anchor">#</a> 6、keep-alive 中的生命周期哪些？</h3> <blockquote><p>keep-alive是 Vue 提供的一个内置组件，用来对组件进行缓存——在组件切换过程中将状态保留在内存中，防
止重复渲染DOM。</p></blockquote> <blockquote><p>如果为一个组件包裹了 keep-alive，那么它会多出两个生命周期：deactivated、activated。同时，beforeDestroy 和 destroyed 就不会再被触发了，因为组件不会被真正销毁。</p></blockquote> <blockquote><p>当组件被换掉时，会被缓存到内存中、触发 deactivated 生命周期；当组件被切回来时，再去缓存里找这个组件、触发 activated钩子函数</p></blockquote> <h3 id="_7、-组件通信"><a href="#_7、-组件通信" class="header-anchor">#</a> 7、 组件通信</h3> <p><strong>组件通信的方式如下:</strong></p> <p>（1）父子组件间通信</p> <div class="language-js extra-class"><pre class="language-js"><code>子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事
件来向父组件发送数据。

通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得
父组件，这样也可以实现通信。

使用 provide<span class="token operator">/</span>inject，在父组件中通过 provide提供变量，在子组件中通过 inject 来将变量注入到组件
中。不论子组件有多深，只要调用了 inject 那么就可以注入 provide中的数据。
</code></pre></div><p>（2）兄弟组件间通信</p> <div class="language-js extra-class"><pre class="language-js"><code>使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这
个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。

通过 $parent<span class="token operator">/</span>$refs 来获取到兄弟组件，也可以进行通信。
</code></pre></div><p>（3）任意组件之间</p> <div class="language-js extra-class"><pre class="language-js"><code>使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。
</code></pre></div><blockquote><p>如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候可以使用 vuex ，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。</p></blockquote> <h3 id="_8、-vue-router-的懒加载如何实现"><a href="#_8、-vue-router-的懒加载如何实现" class="header-anchor">#</a> 8、 Vue-Router 的懒加载如何实现</h3> <p>非懒加载：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> List <span class="token keyword">from</span> <span class="token string">'@/components/list.vue'</span>
<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">routes</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span> <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/list'</span><span class="token punctuation">,</span> <span class="token literal-property property">component</span><span class="token operator">:</span> List <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>（1）方案一(常用)：使用箭头函数+import动态加载</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">List</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'@/components/list.vue'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">routes</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span> <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/list'</span><span class="token punctuation">,</span> <span class="token literal-property property">component</span><span class="token operator">:</span> List <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>（2）方案二：使用箭头函数+require动态加载</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">routes</span><span class="token operator">:</span> <span class="token punctuation">[</span>
   <span class="token punctuation">{</span>
     <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/list'</span><span class="token punctuation">,</span>
     <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'@/components/list'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> resolve<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>(3)方案三：使用webpack的require.ensure技术，也可以实现按需加载。 这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// r就是resolve</span>
<span class="token keyword">const</span> <span class="token function-variable function">List</span> <span class="token operator">=</span> <span class="token parameter">r</span> <span class="token operator">=&gt;</span> require<span class="token punctuation">.</span><span class="token function">ensure</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">r</span><span class="token punctuation">(</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'@/components/list'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'list'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 路由也是正常的写法  这种是官方推荐的写的 按模块划分懒加载 </span>
<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">routes</span><span class="token operator">:</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{</span>
    <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/list'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">component</span><span class="token operator">:</span> List<span class="token punctuation">,</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'list'</span>
  <span class="token punctuation">}</span>
 <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="_9、-路由的hash和history模式的区别"><a href="#_9、-路由的hash和history模式的区别" class="header-anchor">#</a> 9、 路由的hash和history模式的区别？</h3> <p><strong>Vue-Router有两种模式：hash模式和history模式。默认的路由模式是hash模式。</strong></p> <h4 id="_1-hash模式"><a href="#_1-hash模式" class="header-anchor">#</a> 1. hash模式</h4> <p><strong>简介： hash模式是开发中默认的模式，它的URL带着一个#，例如：www.abc.com/#/vue，它的hash值就是#/vue。</strong></p> <blockquote><p>特点：hash值会出现在URL里面，但是不会出现在HTTP请求中，对后端完全没有影响。所以改变hash值，不会重新加载页面。这种模式的浏览器支持度很好，低版本的IE浏览器也支持这种模式。hash路由被称为是前端路由，已经成为SPA（单页面应用）的标配;</p></blockquote> <p>原理： hash模式的主要原理就是onhashchange()事件：</p> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span><span class="token function-variable function">onhashchange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>oldURL<span class="token punctuation">,</span> event<span class="token punctuation">.</span>newURL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> hash <span class="token operator">=</span> location<span class="token punctuation">.</span>hash<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>使用onhashchange()事件的好处就是，在页面的hash值发生变化时，无需向后端发起请求，window就可以监听事件的改变，并按规则加载相应的代码。除此之外，hash值变化对应的URL都会被浏览器记录下来，这样浏览器就能实现页面的前进和后退。虽然是没有请求后端服务器，但是页面的hash值和对应的URL关联起来了。</p></blockquote> <h4 id="_2-history模式"><a href="#_2-history模式" class="header-anchor">#</a> 2. history模式</h4> <blockquote><p>简介： history模式的URL中没有#，它使用的是传统的路由分发模式，即用户在输入一个URL时，服务器会接收这个请求，并解析这个URL，然后做出相应的逻辑处理。
特点： 当使用history模式时，URL就像这样：abc.com/user/id。相比hash模式更加好看。但是，history模式需要后台配置支持。如果后台没有正确配置，访问时会返回404。
API： history api可以分为两大部分，切换历史状态和修改历史状态：</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code>修改历史状态：包括了 <span class="token constant">HTML5</span> History Interface 中新增的 <span class="token function">pushState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 和 <span class="token function">replaceState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 方
法，这两个方法应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修改时，虽然
修改了url，但浏览器不会立即向后端发送请求。如果要做到改变url但又不刷新页面的效果，就需要前端用上这
两个<span class="token constant">API</span>。

切换历史状态： <span class="token function">包括forward</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">、back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">、go</span><span class="token punctuation">(</span><span class="token punctuation">)</span>三个方法，对应浏览器的前进，后退，跳转操作。
</code></pre></div><blockquote><p>虽然history模式丢弃了丑陋的#。但是，它也有自己的缺点，就是在刷新页面的时候，如果没有相应的路由或资源，就会刷出404来。</p></blockquote> <p>如果想要切换到history模式，就要进行以下配置（后端也要进行配置）：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">mode</span><span class="token operator">:</span> <span class="token string">'history'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">routes</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p><strong>调用 history.pushState() 相比于直接修改 hash，存在以下优势:</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">pushState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 设置的新 <span class="token constant">URL</span> 可以是与当前 <span class="token constant">URL</span> 同源的任意 <span class="token constant">URL</span>；而 hash 只可修改 # 后面的部分，因
此只能设置与当前 <span class="token constant">URL</span> 同文档的 <span class="token constant">URL</span>；

<span class="token function">pushState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 设置的新 <span class="token constant">URL</span> 可以与当前 <span class="token constant">URL</span> 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值
必须与原来不一样才会触发动作将记录添加到栈中；

<span class="token function">pushState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；

<span class="token function">pushState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 可额外设置 title 属性供后续使用。

hash模式下，仅hash符号之前的url会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回<span class="token number">404</span>错
误；history模式下，前端的url必须和实际向后端发起请求的url一致，如果没有对用的路由处理，将返回<span class="token number">404</span>
错误。

</code></pre></div><h3 id="_10、-如何获取页面的hash变化"><a href="#_10、-如何获取页面的hash变化" class="header-anchor">#</a> 10、 如何获取页面的hash变化？</h3> <p><strong>（1）监听$route的变化</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 监听,当路由发生变化的时候执行</span>
<span class="token literal-property property">watch</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">$route</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">handler</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">val<span class="token punctuation">,</span> oldVal</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 深度观察监听</span>
    <span class="token literal-property property">deep</span><span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre></div><p><strong>（2）window.location.hash读取#值 window.location.hash 的值可读可写，读取来判断状态是否改变，写入时可以在不重载网页的前提下，添加一条历史访问记录</strong></p> <h3 id="_11、-route-和-router-的区别"><a href="#_11、-route-和-router-的区别" class="header-anchor">#</a> 11、$route 和$router 的区别?</h3> <div class="language-js extra-class"><pre class="language-js"><code>$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信
息参数

$router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。
</code></pre></div><h3 id="_12、如何定义动态路由-如何获取传过来的动态参数"><a href="#_12、如何定义动态路由-如何获取传过来的动态参数" class="header-anchor">#</a> 12、如何定义动态路由？如何获取传过来的动态参数？</h3> <p>（1）param方式</p> <blockquote><p>配置路由格式：/router/:id</p></blockquote> <blockquote><p>传递的方式：在path后面跟上对应的值</p></blockquote> <blockquote><p>传递后形成的路径：/router/123</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1</span>）路由定义

<span class="token comment">//在APP.vue中</span>
<span class="token operator">&lt;</span>router<span class="token operator">-</span>link <span class="token operator">:</span>to<span class="token operator">=</span><span class="token string">&quot;'/user/'+userId&quot;</span> replace<span class="token operator">&gt;</span>用户<span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">&gt;</span>    

<span class="token comment">//在index.js</span>
<span class="token punctuation">{</span>
   path<span class="token operator">:</span> <span class="token string">'/user/:userid'</span><span class="token punctuation">,</span>
   component<span class="token operator">:</span> User<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token number">2</span>）路由跳转

<span class="token comment">// 方法1：</span>
<span class="token operator">&lt;</span>router<span class="token operator">-</span>link <span class="token operator">:</span>to<span class="token operator">=</span><span class="token string">&quot;{ name: 'users', params: { uname: wade }}&quot;</span><span class="token operator">&gt;</span>按钮<span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">&gt;</span>

<span class="token comment">// 方法2：</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">'users'</span><span class="token punctuation">,</span><span class="token literal-property property">params</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token literal-property property">uname</span><span class="token operator">:</span>wade<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 方法3：</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'/user/'</span> <span class="token operator">+</span> wade<span class="token punctuation">)</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token number">3</span>）参数获取 通过 $route<span class="token punctuation">.</span>params<span class="token punctuation">.</span>userid 获取传递的值
</code></pre></div><p>（2）query方式</p> <blockquote><p>配置路由格式：/router，也就是普通配置</p></blockquote> <blockquote><p>传递的方式：对象中使用query的key作为传递方式</p></blockquote> <blockquote><p>传递后形成的路径：/route?id=123</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1</span>）路由定义

<span class="token comment">//方式1：直接在router-link 标签上以对象的形式</span>
<span class="token operator">&lt;</span>router<span class="token operator">-</span>link <span class="token operator">:</span>to<span class="token operator">=</span><span class="token string">&quot;{path:'/profile',query:{name:'why',age:28,height:188}}&quot;</span><span class="token operator">&gt;</span>档案<span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">&gt;</span>

<span class="token comment">// 方式2：写成按钮以点击事件形式</span>
<span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">'profileClick'</span><span class="token operator">&gt;</span>我的<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>    

<span class="token function">profileClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">&quot;/profile&quot;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">query</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;kobi&quot;</span><span class="token punctuation">,</span>
        <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token string">&quot;28&quot;</span><span class="token punctuation">,</span>
        <span class="token literal-property property">height</span><span class="token operator">:</span> <span class="token number">198</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token number">2</span>）跳转方法

<span class="token comment">// 方法1：</span>
<span class="token operator">&lt;</span>router<span class="token operator">-</span>link <span class="token operator">:</span>to<span class="token operator">=</span><span class="token string">&quot;{ name: 'users', query: { uname: james }}&quot;</span><span class="token operator">&gt;</span>按钮<span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">&gt;</span>

<span class="token comment">// 方法2：</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'users'</span><span class="token punctuation">,</span> <span class="token literal-property property">query</span><span class="token operator">:</span><span class="token punctuation">{</span> <span class="token literal-property property">uname</span><span class="token operator">:</span>james <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 方法3：</span>
<span class="token operator">&lt;</span>router<span class="token operator">-</span>link <span class="token operator">:</span>to<span class="token operator">=</span><span class="token string">&quot;{ path: '/user', query: { uname:james }}&quot;</span><span class="token operator">&gt;</span>按钮<span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">&gt;</span>

<span class="token comment">// 方法4：</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/user'</span><span class="token punctuation">,</span> <span class="token literal-property property">query</span><span class="token operator">:</span><span class="token punctuation">{</span> <span class="token literal-property property">uname</span><span class="token operator">:</span>james <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 方法5：</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'/user?uname='</span> <span class="token operator">+</span> jsmes<span class="token punctuation">)</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token number">3</span>）获取参数

通过$route<span class="token punctuation">.</span>query 获取传递的值
</code></pre></div><h3 id="_13、-vue-router-路由钩子在生命周期的体现"><a href="#_13、-vue-router-路由钩子在生命周期的体现" class="header-anchor">#</a> 13、 Vue-router 路由钩子在生命周期的体现</h3> <h4 id="一、vue-router导航守卫"><a href="#一、vue-router导航守卫" class="header-anchor">#</a> 一、Vue-Router导航守卫</h4> <p><strong>有的时候，需要通过路由来进行一些操作，比如最常见的登录权限验证，当用户满足条件时，才让其进入导航，否则就取消跳转，并跳到登录页面让其登录。 为此有很多种方法可以植入路由的导航过程：全局的，单个路由独享的，或者组件级的</strong></p> <p><strong>1、全局路由钩子</strong>
vue-router全局有三个路由钩子;</p> <ul><li>router.beforeEach 全局前置守卫 进入路由之前</li> <li>router.beforeResolve 全局解析守卫（2.5.0+）在 beforeRouteEnter 调用之后调用</li> <li>router.afterEach 全局后置钩子 进入路由之后</li></ul> <p><strong>具体使用∶</strong></p> <blockquote><p>beforeEach（判断是否登录了，没登录就跳转到登录页）</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code>router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>  
    <span class="token keyword">let</span> ifInfo <span class="token operator">=</span> <span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$common<span class="token punctuation">.</span><span class="token function">getSession</span><span class="token punctuation">(</span><span class="token string">'userData'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 判断是否登录的存储信息</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ifInfo<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token comment">// sessionStorage里没有储存user信息    </span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>to<span class="token punctuation">.</span>path <span class="token operator">==</span> <span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
            <span class="token comment">//如果是登录页面路径，就直接next()      </span>
            <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> 
            <span class="token comment">//不然就跳转到登录      </span>
            Message<span class="token punctuation">.</span><span class="token function">warning</span><span class="token punctuation">(</span><span class="token string">&quot;请重新登录！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     
            window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>href <span class="token operator">=</span> <span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$loginUrl<span class="token punctuation">;</span>    
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    
        <span class="token keyword">return</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><blockquote><p>afterEach （跳转之后滚动条回到顶部）</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code>router<span class="token punctuation">.</span><span class="token function">afterEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>  
    <span class="token comment">// 跳转之后滚动条回到顶部  </span>
    window<span class="token punctuation">.</span><span class="token function">scrollTo</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>2、单个路由独享钩子</strong></p> <p><strong>beforeEnter</strong> 如果不想全局配置守卫的话，可以为某些路由单独配置守卫，有三个参数∶ to、from、next</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">[</span>    
    <span class="token punctuation">{</span>        
        <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span>        
        <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'login'</span><span class="token punctuation">,</span>        
        <span class="token literal-property property">component</span><span class="token operator">:</span> login<span class="token punctuation">,</span>        
        <span class="token function-variable function">beforeEnter</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>          
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'即将进入登录页面'</span><span class="token punctuation">)</span>          
            <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        
        <span class="token punctuation">}</span>    
    <span class="token punctuation">}</span>
<span class="token punctuation">]</span>
</code></pre></div><p><strong>3、组件内钩子</strong></p> <p><code>beforeRouteUpdate</code>、<code>beforeRouteEnter</code>、<code>beforeRouteLeave</code>
这三个钩子都有三个参数∶to、from、nex</p> <ul><li><code>beforeRouteEnter</code>∶ 进入组件前触发</li> <li><code>beforeRouteUpdate</code>∶ 当前地址改变并且改组件被复用时触发，举例来说，带有动态参数的路径foo/∶id，在 /foo/1 和 /foo/2 之间跳转的时候，由于会渲染同样的foa组件，这个钩子在这种情况下就会被调用</li> <li><code>beforeRouteLeave</code>∶ 离开组件被调用</li></ul> <blockquote><p>注意点，beforeRouteEnter组件内还访问不到this，因为该守卫执行前组件实例还没有被创建，需要传一个回调给 next来访问，例如：</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">beforeRouteEnter</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      
    <span class="token function">next</span><span class="token punctuation">(</span><span class="token parameter">target</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>        
        <span class="token keyword">if</span> <span class="token punctuation">(</span>from<span class="token punctuation">.</span>path <span class="token operator">==</span> <span class="token string">'/classProcess'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          
            target<span class="token punctuation">.</span>isFromProcess <span class="token operator">=</span> <span class="token boolean">true</span>        
        <span class="token punctuation">}</span>      
    <span class="token punctuation">}</span><span class="token punctuation">)</span>    
<span class="token punctuation">}</span>
</code></pre></div><h4 id="二、vue路由钩子在生命周期函数的体现"><a href="#二、vue路由钩子在生命周期函数的体现" class="header-anchor">#</a> 二、Vue路由钩子在生命周期函数的体现</h4> <p><strong>1.完整的路由导航解析流程（不包括其他生命周期）</strong></p> <ul><li>触发进入其他路由。</li> <li>调用要离开路由的组件守卫beforeRouteLeave</li> <li>调用局前置守卫∶ beforeEach</li> <li>在重用的组件里调用 beforeRouteUpdate</li> <li>调用路由独享守卫 beforeEnter。</li> <li>解析异步路由组件。</li> <li>在将要进入的路由组件中调用 beforeRouteEnter</li> <li>调用全局解析守卫 beforeResolve</li> <li>导航被确认。</li> <li>调用全局后置钩子的 afterEach 钩子。</li> <li>触发DOM更新（mounted）。</li> <li>执行beforeRouteEnter 守卫中传给 next 的回调函数</li></ul> <p><strong>2.触发钩子的完整顺序</strong></p> <blockquote><p>路由导航、keep-alive、和组件生命周期钩子结合起来的，触发顺序，假设是从a组件离开，第一次进入b组件∶</p></blockquote> <ul><li>beforeRouteLeave：路由组件的组件离开路由前钩子，可取消路由离开。</li> <li>beforeEach：路由全局前置守卫，可用于登录验证、全局路由loading等。</li> <li>beforeEnter：路由独享守卫</li> <li>beforeRouteEnter：路由组件的组件进入路由前钩子。</li> <li>beforeResolve：路由全局解析守卫</li> <li>afterEach：路由全局后置钩子</li> <li>beforeCreate：组件生命周期，不能访问tAis。</li> <li>created;组件生命周期，可以访问tAis，不能访问dom。</li> <li>beforeMount：组件生命周期</li> <li>deactivated：离开缓存组件a，或者触发a的beforeDestroy和destroyed组件销毁钩子。</li> <li>mounted：访问/操作dom。</li> <li>activated：进入缓存组件，进入a的嵌套子组件（如果有的话）。</li> <li>执行beforeRouteEnter回调函数next。</li></ul> <p><strong>3.导航行为被触发到导航完成的整个过程</strong></p> <ul><li>导航行为被触发，此时导航未被确认。</li> <li>在失活的组件里调用离开守卫 beforeRouteLeave。</li> <li>调用全局的 beforeEach守卫。</li> <li>在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。</li> <li>在路由配置里调用 beforeEnteY。</li> <li>解析异步路由组件（如果有）。</li> <li>在被激活的组件里调用 beforeRouteEnter。</li> <li>调用全局的 beforeResolve 守卫（2.5+），标示解析阶段完成。</li> <li>导航被确认。</li> <li>调用全局的 afterEach 钩子。</li> <li>非重用组件，开始组件实例的生命周期：beforeCreate&amp;created、beforeMount&amp;mounted</li> <li>触发 DOM 更新。</li> <li>用创建好的实例调用 beforeRouteEnter守卫中传给 next 的回调函数。</li> <li>导航完成</li></ul> <h3 id="_14、vue-router跳转和location-href有什么区别"><a href="#_14、vue-router跳转和location-href有什么区别" class="header-anchor">#</a> 14、Vue-router跳转和location.href有什么区别?</h3> <ul><li><p><strong>使用 location.href= /url 来跳转，简单方便，但是刷新了页面；</strong></p></li> <li><p><strong>使用 history.pushState( /url ) ，无刷新页面，静态跳转；</strong></p></li> <li><p><strong>引进 router ，然后使用 router.push( /url ) 来跳转，使用了 diff 算法，实现了按需加载，减少了 dom 的消耗。其实使用 router 跳转和使用 history.pushState() 没什么差别的，因为vue-router就是用了 history.pushState() ，尤其是在history模式下。</strong></p></li></ul> <h3 id="_15、-params和query的区别"><a href="#_15、-params和query的区别" class="header-anchor">#</a> 15、 params和query的区别?</h3> <blockquote><p>用法：query要用path来引入，params要用name来引入，接收参数都是类似的，分别是 this.$route.
query.name 和 this.$route.params.name 。</p></blockquote> <blockquote><p>url地址显示：query更加类似于ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地
址栏中显示参数，后者则不显示</p></blockquote> <blockquote><p>注意：query刷新不会丢失query里面的数据 params刷新会丢失 params里面的数据。</p></blockquote> <h3 id="_16、-vue-router-导航守卫有哪些"><a href="#_16、-vue-router-导航守卫有哪些" class="header-anchor">#</a> 16、 Vue-router 导航守卫有哪些</h3> <ul><li><p>全局前置/钩子：beforeEach、beforeResolve、afterEach</p></li> <li><p>路由独享的守卫：beforeEnter</p></li> <li><p>组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave</p></li></ul> <h3 id="_17、-vuex-的原理"><a href="#_17、-vuex-的原理" class="header-anchor">#</a> 17、 Vuex 的原理</h3> <p><strong>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</strong></p> <ul><li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，
那么相应的组件也会相应地得到高效更新。</li> <li>改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化.</li></ul> <p><strong>（1）核心流程中的主要功能：</strong></p> <ul><li>Vue Components 是 vue 组件，组件会触发（dispatch）一些事件或动作，也就是图中的 Actions;</li> <li>在组件中发出的动作，肯定是想获取或者改变数据的，但是在 vuex 中，数据是集中管理的，不能直接去更改数据，所以会把这个动作提交（Commit）到 Mutations 中;</li> <li>然后 Mutations 就去改变（Mutate）State 中的数据;</li> <li>当 State 中的数据被改变之后，就会重新渲染（Render）到 Vue Components 中去，组件展示更新后的数据，完成一个流程。</li></ul> <p><strong>（2）各模块在核心流程中的主要功能：</strong></p> <ul><li><code>Vue Components</code>∶ Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。</li> <li><code>dispatch</code>∶操作行为触发方法，是唯一能执行action的方法。</li> <li><code>actions</code>∶ 操作行为处理模块。负责处理Vue Components接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。</li> <li><code>commit</code>∶状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。</li> <li><code>mutations</code>∶状态改变操作方法。是Vuex修改state的唯一推荐方法，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。</li> <li><code>state</code>∶ 页面状态管理容器对象。集中存储Vuecomponents中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。</li> <li><code>getters</code>∶ state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。</li></ul> <h3 id="_18、vuex中action和mutation的区别"><a href="#_18、vuex中action和mutation的区别" class="header-anchor">#</a> 18、Vuex中action和mutation的区别</h3> <blockquote><p>mutation中的操作是一系列的同步函数，用于修改state中的变量的的状态。当使用vuex时需要通过commit来提交需要操作的内容。mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p></blockquote> <p>而Action类似于mutation，不同点在于：</p> <ul><li>Action 可以包含任意异步操作。</li> <li>Action 提交的是 mutation，而不是直接变更状态。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">state</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">mutations</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">increment</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      state<span class="token punctuation">.</span>count<span class="token operator">++</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">actions</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">increment</span> <span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      context<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'increment'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><blockquote><p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。</p></blockquote> <p>所以，两者的不同点如下</p> <ul><li>Mutation专注于修改State，理论上是修改State的唯一途径；Action业务代码、异步请求。</li> <li>Mutation：必须同步执行；Action：可以异步，但不能直接操作State。
在视图更新时，先触发actions，actions再触发mutation</li> <li>mutation的参数是state，它包含store中的数据；store的参数是context，它是 state 的父级，包含 state、getters</li></ul> <h3 id="_19、redux-和-vuex-有什么区别-它们的共同思想"><a href="#_19、redux-和-vuex-有什么区别-它们的共同思想" class="header-anchor">#</a> 19、Redux 和 Vuex 有什么区别，它们的共同思想</h3> <p><strong>（1）Redux 和 Vuex区别</strong></p> <ul><li>Vuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch，只需在对应的mutation函数里改变state值即可</li> <li>Vuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可</li> <li>Vuex数据流的顺序是∶View调用store.commit提交对应的请求到Store中对应的mutation函数-&gt;store改变（vue检测到数据变化自动渲染）</li></ul> <blockquote><p>通俗点理解就是，vuex 弱化 dispatch，通过commit进行 store状态的一次更变;取消了action概念，不必传入特定的 action形式进行指定变更;弱化reducer，基于commit参数直接对数据进行转变，使得框架更加简易;</p></blockquote> <p><strong>（2）共同思想</strong></p> <ul><li>单—的数据源</li> <li>变化可以预测</li></ul> <blockquote><p>本质上：redux与vuex都是对mvvm思想的服务，将数据从视图中抽离的一种方案; 形式上：vuex借鉴了redux，将store作为全局的数据中心，进行mode管理;</p></blockquote> <h3 id="_20、-vuex有哪几种属性"><a href="#_20、-vuex有哪几种属性" class="header-anchor">#</a> 20、 Vuex有哪几种属性？</h3> <p><strong>有五种，分别是 State、 Getter、Mutation 、Action、 Module</strong></p> <ul><li>state =&gt; 基本数据(数据源存放地)</li> <li>getters =&gt; 从基本数据派生出来的数据</li> <li>mutations =&gt; 提交更改数据的方法，同步</li> <li>actions =&gt; 像一个装饰器，包裹mutations，使之可以异步。</li> <li>modules =&gt; 模块化Vuex</li></ul> <h3 id="_21、为什么-vuex-的-mutation-中不能做异步操作"><a href="#_21、为什么-vuex-的-mutation-中不能做异步操作" class="header-anchor">#</a> 21、为什么 Vuex 的 mutation 中不能做异步操作？</h3> <ul><li><p>Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。</p></li> <li><p>每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。</p></li></ul> <h3 id="_22、如何在组件中批量使用vuex的getter属性"><a href="#_22、如何在组件中批量使用vuex的getter属性" class="header-anchor">#</a> 22、如何在组件中批量使用Vuex的getter属性？</h3> <p><strong>使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span>mapGetters<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vuex'</span>
<span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>
    <span class="token literal-property property">computed</span><span class="token operator">:</span><span class="token punctuation">{</span>
        <span class="token operator">...</span><span class="token function">mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'total'</span><span class="token punctuation">,</span><span class="token string">'discountTotal'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_23、如何在组件中重复使用vuex的mutation"><a href="#_23、如何在组件中重复使用vuex的mutation" class="header-anchor">#</a> 23、如何在组件中重复使用Vuex的mutation？</h3> <p><strong>使用mapMutations辅助函数,在组件中这么使用</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> mapMutations <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vuex'</span>
<span class="token literal-property property">methods</span><span class="token operator">:</span><span class="token punctuation">{</span>
    <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        <span class="token literal-property property">setNumber</span><span class="token operator">:</span><span class="token string">'SET_NUMBER'</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>然后调用this.setNumber(10)相当调用this.$store.commit('SET_NUMBER',10)</strong></p></div></div></div> <div class="el-card py-3 px-3 mb-4 is-always-shadow"><!----><div class="el-card__body"><span>时人不识临云木，直待凌云道始高</span></div></div> <div class="el-card mb-4 is-always-shadow"><div class="el-card__header"><div class="clearfix"><h5 class="m-0">
            Read more
          </h5></div></div><div class="el-card__body"> <div class="container featured-posts my-4"><div class="el-carousel el-carousel--horizontal el-carousel--card"><div class="el-carousel__container" style="height:300px;"><button type="button" class="el-carousel__arrow el-carousel__arrow--left" style="display:none;"><i class="el-icon-arrow-left"></i></button><button type="button" class="el-carousel__arrow el-carousel__arrow--right" style="display:none;"><i class="el-icon-arrow-right"></i></button><div class="el-carousel__item carousel-card bg-cover border-10 el-carousel__item--card" style="transform:translateX(0px) scale(1);ms-transform:translateX(0px) scale(1);webkit-transform:translateX(0px) scale(1);display:none;background-image:url(https://img.zcool.cn/community/01f9fc5c432d69a801203d22d4b81a.jpg@1280w_1l_2o_100sh.jpg);background-blend-mode:multiply;background-size:cover;background-color:rgba(0,0,0,0.3);"><div class="el-carousel__mask"></div><div class="carousel-card-content d-flex justify-content-center align-items-center flex-column h-100"><h4 class="story-title text-center h4 mb-3 text-light">
          JavaScript基础问题(一)
        </h4> <a href="/2023/02/13/js%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-01/" class="el-button el-button--primary">
          Read this Post <i class="el-icon-arrow-right"></i></a></div></div><div class="el-carousel__item carousel-card bg-cover border-10 el-carousel__item--card" style="transform:translateX(0px) scale(1);ms-transform:translateX(0px) scale(1);webkit-transform:translateX(0px) scale(1);display:none;background-image:url(https://www.2008php.com/2011_Website_appreciate/2011-09-23/20110923163645.jpg);background-blend-mode:multiply;background-size:cover;background-color:rgba(0,0,0,0.3);"><div class="el-carousel__mask"></div><div class="carousel-card-content d-flex justify-content-center align-items-center flex-column h-100"><h4 class="story-title text-center h4 mb-3 text-light">
          JavaScript基础问题(二)
        </h4> <a href="/2023/02/14/js%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-02/" class="el-button el-button--primary">
          Read this Post <i class="el-icon-arrow-right"></i></a></div></div><div class="el-carousel__item carousel-card bg-cover border-10 el-carousel__item--card" style="transform:translateX(0px) scale(1);ms-transform:translateX(0px) scale(1);webkit-transform:translateX(0px) scale(1);display:none;background-image:url(https://i.picsum.photos/id/79/800/600.jpg);background-blend-mode:multiply;background-size:cover;background-color:rgba(0,0,0,0.3);"><div class="el-carousel__mask"></div><div class="carousel-card-content d-flex justify-content-center align-items-center flex-column h-100"><h4 class="story-title text-center h4 mb-3 text-light">
          Create a modern vuepress blog in 5 minutes!
        </h4> <a href="/2019/10/14/vuepress-modern-blog-theme/" class="el-button el-button--primary">
          Read this Post <i class="el-icon-arrow-right"></i></a></div></div><div class="el-carousel__item carousel-card bg-cover border-10 el-carousel__item--card" style="transform:translateX(0px) scale(1);ms-transform:translateX(0px) scale(1);webkit-transform:translateX(0px) scale(1);display:none;background-image:url(https://img.zcool.cn/community/01cf6858635528a8012060c8b33f77.jpg@1280w_1l_2o_100sh.jpg);background-blend-mode:multiply;background-size:cover;background-color:rgba(0,0,0,0.3);"><div class="el-carousel__mask"></div><div class="carousel-card-content d-flex justify-content-center align-items-center flex-column h-100"><h4 class="story-title text-center h4 mb-3 text-light">
          前端常见面试题
        </h4> <a href="/2023/02/15/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-03/" class="el-button el-button--primary">
          Read this Post <i class="el-icon-arrow-right"></i></a></div></div><div class="el-carousel__item carousel-card bg-cover border-10 el-carousel__item--card" style="transform:translateX(0px) scale(1);ms-transform:translateX(0px) scale(1);webkit-transform:translateX(0px) scale(1);display:none;background-image:url(http://pic.bizhi360.com/bbpic/76/5776.jpg);background-blend-mode:multiply;background-size:cover;background-color:rgba(0,0,0,0.3);"><div class="el-carousel__mask"></div><div class="carousel-card-content d-flex justify-content-center align-items-center flex-column h-100"><h4 class="story-title text-center h4 mb-3 text-light">
          前端常见vue面试题(二)
        </h4> <a href="/2023/02/16/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98vue-05/" aria-current="page" class="el-button el-button--primary router-link-exact-active router-link-active">
          Read this Post <i class="el-icon-arrow-right"></i></a></div></div><div class="el-carousel__item carousel-card bg-cover border-10 el-carousel__item--card" style="transform:translateX(0px) scale(1);ms-transform:translateX(0px) scale(1);webkit-transform:translateX(0px) scale(1);display:none;background-image:url(http://img.pconline.com.cn/images/upload/upc/tx/itbbs/2003/10/c9/196420048_1583835136058.jpg);background-blend-mode:multiply;background-size:cover;background-color:rgba(0,0,0,0.3);"><div class="el-carousel__mask"></div><div class="carousel-card-content d-flex justify-content-center align-items-center flex-column h-100"><h4 class="story-title text-center h4 mb-3 text-light">
          前端常见vue面试题(一)
        </h4> <a href="/2023/02/16/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98vue-04/" class="el-button el-button--primary">
          Read this Post <i class="el-icon-arrow-right"></i></a></div></div><div class="el-carousel__item carousel-card bg-cover border-10 el-carousel__item--card" style="transform:translateX(0px) scale(1);ms-transform:translateX(0px) scale(1);webkit-transform:translateX(0px) scale(1);display:none;background-image:url(http://up.deskcity.org/pic_source/d6/a6/3c/d6a63c350c8ea49404a71face8f969b5.jpg);background-blend-mode:multiply;background-size:cover;background-color:rgba(0,0,0,0.3);"><div class="el-carousel__mask"></div><div class="carousel-card-content d-flex justify-content-center align-items-center flex-column h-100"><h4 class="story-title text-center h4 mb-3 text-light">
          前端常见vue3面试题(三)
        </h4> <a href="/2023/02/16/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98vue3-06/" class="el-button el-button--primary">
          Read this Post <i class="el-icon-arrow-right"></i></a></div></div></div><ul class="el-carousel__indicators el-carousel__indicators--horizontal el-carousel__indicators--outside"></ul></div></div></div></div> <div class="el-card is-always-shadow"><div class="el-card__header"><div class="clearfix"><h5 class="m-0">
            Tags
          </h5></div></div><div class="el-card__body"> <div><a href="/tag/vue" class="el-button el-button--small text-decoration-none d-inline-block mb-3">
            #vue
          </a><a href="/tag/面试题" class="el-button el-button--small text-decoration-none d-inline-block mb-3">
            #面试题
          </a></div></div></div> <!----></main></div> <footer class="footer" data-v-85a2b3d2><div class="footer-left-wrap" data-v-85a2b3d2><ul class="contact" data-v-85a2b3d2><li class="contact-item" data-v-85a2b3d2><a href="https://github.com/yeCodings" target="_blank" rel="noopener noreferrer" class="external" data-v-85a2b3d2><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github" data-v-85a2b3d2><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" data-v-85a2b3d2></path></svg>
          
        </a></li><li class="contact-item" data-v-85a2b3d2><a href="https://instagram.com" target="_blank" rel="noopener noreferrer" class="external" data-v-85a2b3d2><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-instagram" data-v-85a2b3d2><rect x="2" y="2" width="20" height="20" rx="5" ry="5" data-v-85a2b3d2></rect><path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z" data-v-85a2b3d2></path><line x1="17.5" y1="6.5" x2="17.5" y2="6.5" data-v-85a2b3d2></line></svg>
          
        </a></li><li class="contact-item" data-v-85a2b3d2><a href="https://linkedin.com" target="_blank" rel="noopener noreferrer" class="external" data-v-85a2b3d2><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-linkedin" data-v-85a2b3d2><path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z" data-v-85a2b3d2></path><rect x="2" y="9" width="4" height="12" data-v-85a2b3d2></rect><circle cx="4" cy="4" r="2" data-v-85a2b3d2></circle></svg>
          
        </a></li><li class="contact-item" data-v-85a2b3d2><a href="https://twitter.com" target="_blank" rel="noopener noreferrer" class="external" data-v-85a2b3d2><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-twitter" data-v-85a2b3d2><path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z" data-v-85a2b3d2></path></svg>
          
        </a></li></ul></div> <div class="footer-right-wrap" data-v-85a2b3d2><ul class="copyright" data-v-85a2b3d2><li class="copyright-item" data-v-85a2b3d2><a data-v-85a2b3d2>MIT Licensed | Copyright © 2018-present Vue.js</a></li></ul></div></footer> <!----></div><div class="global-ui"><!----><div class="Sakura" data-v-248d85d6><canvas id="canvas_sakura" style="z-index:-1;" data-v-248d85d6></canvas></div></div></div>
    <script src="/assets/js/app.910dc115.js" defer></script><script src="/assets/js/4.5b8d8b22.js" defer></script><script src="/assets/js/18.6e7e20b1.js" defer></script><script src="/assets/js/6.d2ea23d8.js" defer></script>
  </body>
</html>

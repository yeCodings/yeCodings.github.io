(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{452:function(t,s,a){"use strict";a.r(s);var n=a(4),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h3",{attrs:{id:"_1-javascript-原型-原型链-有什么特点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-javascript-原型-原型链-有什么特点"}},[t._v("#")]),t._v(" 1. JavaScript 原型，原型链？有什么特点？")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("在 js 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性值，\n这个属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构\n造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性\n对应的值，在 ES5 中这个指针被称为对象的原型。一般来说我们是不应该能够获取到这个值的，但是现在\n浏览器中都实现了 __proto__ 属性来让我们访问这个属性，但是我们最好不要使用这个属性，因为它不\n是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" 方法，我们可以通过这个方法来获\n取对象的原型。\n\n当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，\n这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是\nObject.prototype 所以这就是我们新建的对象为什么能够使用 toString"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" 等方法的原因。\n\n特点：\nJavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我\n们修改原型时，与之相关的对象也会继承这一改变。\n\n")])])]),s("h3",{attrs:{id:"_2-javascript获取原型的方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-javascript获取原型的方法"}},[t._v("#")]),t._v(" 2. javaScript获取原型的方法")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("p.proto\np.constructor.prototype\nObject.getPrototypeOf"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("h3",{attrs:{id:"_3-javascript-继承的几种实现方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-javascript-继承的几种实现方式"}},[t._v("#")]),t._v(" 3. JavaScript 继承的几种实现方式？")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("我了解的 js 中实现继承的几种方式有：\n\n（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，\n  会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。\n\n（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来\n  实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法\n  的复用，并且超类型原型定义的方法子类型也没有办法访问到。\n\n（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函\n  数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式\n  解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用\n  了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。\n\n（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，\n  向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造\n  一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" 方法就是原型式\n  继承的实现。缺点与原型链方式相同。\n\n（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，\n  然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。\n  这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法\n  实现函数的复用。\n\n（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不\n  必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建\n  不必要的属性。\n")])])]),s("h3",{attrs:{id:"_4-寄生式组合继承的实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-寄生式组合继承的实现"}},[t._v("#")]),t._v(" 4. 寄生式组合继承的实现？")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" Person"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  this.name "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\nPerson.prototype.sayName "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-name function"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  console.log"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"My name is "')]),t._v(" + this.name + "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"."')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" Student"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("name, grade"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  Person.call"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("this, name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  this.grade "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" grade"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\nStudent.prototype "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Object.create"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Person.prototype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nStudent.prototype.constructor "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Student"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\nStudent.prototype.sayMyGrade "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-name function"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  console.log"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"My grade is "')]),t._v(" + this.grade + "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"."')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("h3",{attrs:{id:"_4-javascript-的作用域链"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-javascript-的作用域链"}},[t._v("#")]),t._v(" 4. Javascript 的作用域链")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和\n函数。\n\n作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前\n端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。\n\n当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。\n\n作用域链的创建过程跟执行上下文的建立有关"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v("\n")])])]),s("h3",{attrs:{id:"_5-谈谈-this-对象的理解。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-谈谈-this-对象的理解。"}},[t._v("#")]),t._v(" 5. 谈谈 This 对象的理解。")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以\n通过四种调用模式来判断。\n")])])]),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.")]),t._v("第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),t._v(" 指向全局对象。\n\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2.")]),t._v("第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),t._v(" 指向这个对象。\n\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3.")]),t._v("第三种是构造器调用模式，如果一个函数用 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" 调用时，函数执行前会新创建一个对象，"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),t._v(" 指向这个\n新创建的对象。\n\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4.")]),t._v("第四种是 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),t._v(" 指向。\n  其中 apply 方法接收两个参数：一个是 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),t._v(" 绑定的对象，一个是参数数组。call 方法接收的参数，\n  第一个是 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),t._v(" 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" 方法\n  时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),t._v(" 绑定了传入对象\n  的新函数。这个函数的 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),t._v(" 指向除了使用 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" 时会被改变，其他情况下都不会改变\n")])])]),s("p",[t._v("这四种方式，使用构造器调用模式的优先级最高，然后是 apply 、 call 和 bind 调用模式，然后是\n方法调用模式，然后是函数调用模式。")]),t._v(" "),s("h3",{attrs:{id:"_6-eval-是做什么的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-eval-是做什么的"}},[t._v("#")]),t._v(" 6. eval 是做什么的？")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("它的功能是把对应的字符串解析成 JS 代码并运行。\n\n应该避免使用 eval，不安全，非常耗性能（2次，一次解析成 js 语句，一次执行）。\n")])])]),s("h3",{attrs:{id:"_7-1-2-3-map-parseint-答案是多少"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-1-2-3-map-parseint-答案是多少"}},[t._v("#")]),t._v(' 7. ["1", "2", "3"].map(parseInt) 答案是多少？')]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("parseInt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" 函数能解析一个字符串，并返回一个整数，需要两个参数 "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("val, radix"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("，其中 \nradix 表示要解析的数字的基数。（该值介于 "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" ~ "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("36")]),t._v(" 之间，并且字符串中的数字不能大于\nradix 才能正确返回数字结果值）。\n\n\n此处 map 传了 "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v(" 个参数 "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("element, index, array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("，默认第三个参数被忽略掉，因此三次传\n入的参数分别为 "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"1-0"')]),t._v(", "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"2-1"')]),t._v(", "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"3-2"')]),t._v("\n\n因为字符串的值不能大于基数，因此后面两次调用均失败，返回 NaN ，第一次基数为 "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" ，按十进制\n解析返回 "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("。\n")])])]),s("h3",{attrs:{id:"_8-事件是什么-ie-与火狐的事件机制有什么区别-如何阻止冒泡"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-事件是什么-ie-与火狐的事件机制有什么区别-如何阻止冒泡"}},[t._v("#")]),t._v(" 8. 事件是什么？IE 与火狐的事件机制有什么区别？如何阻止冒泡？")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(".事件是用户操作网页时发生的交互动作，比如 click/move， 事件除了用户触发的动作外，还可\n以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有\n相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。\n\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(".事件处理机制：IE 支持事件冒泡、Firefox 同时支持两种事件模型，也就是：事件冒泡和事件捕获。\n\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v(".event.stopPropagation"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" 或者 ie 下的方法 event.cancelBubble "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v("\n")])])]),s("h3",{attrs:{id:"_9-三种事件模型是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-三种事件模型是什么"}},[t._v("#")]),t._v(" 9. 三种事件模型是什么？")]),t._v(" "),s("p",[t._v("事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型。")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("第一种事件模型是最早的 DOM0 级模型，这种模型不会传播，所以没有事件流的概念，但是现在有的\n浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听\n函数。这种方式是所有浏览器都兼容的。\n\n第二种事件模型是 IE 事件模型，在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件\n冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件\n从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种\n模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。\n\n第三种是 DOM2 级事件模型，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶\n段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监\n听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的\n函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。\n")])])]),s("h3",{attrs:{id:"_10-事件委托是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-事件委托是什么"}},[t._v("#")]),t._v(" 10. 事件委托是什么？")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过\n事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个\n子元素的事件，这种方式称为事件代理。\n\n使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理\n我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生\n的事件会交给父元素中的监听函数来处理。\n")])])]),s("h3",{attrs:{id:"_11-什么是闭包-为什么要用它"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_11-什么是闭包-为什么要用它"}},[t._v("#")]),t._v(" 11. 什么是闭包，为什么要用它？")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创\n建的函数可以访问到当前函数的局部变量。\n")])])]),s("p",[t._v("闭包有两个常用的用途。")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包\n函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。\n\n函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象\n的引用，所以这个变量对象不会被回收。\n\n其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。\n")])])]),s("h3",{attrs:{id:"_12-如何判断一个对象是否属于某个类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_12-如何判断一个对象是否属于某个类"}},[t._v("#")]),t._v(" 12. 如何判断一个对象是否属于某个类?")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("第一种方式是使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的\n任何位置。\n\n第二种方式可以通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，\n但是这种方式不是很安全，因为 constructor 属性可以被改写。\n\n第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" 方法\n来打印对象的"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Class"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" 属性来进行判断。\n")])])]),s("h3",{attrs:{id:"_13-instanceof-的作用及实现。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_13-instanceof-的作用及实现。"}},[t._v("#")]),t._v(" 13.  instanceof 的作用及实现。")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("// instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。\n// 实现：\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" myInstanceof"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("left, right"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("let")]),t._v(" proto "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Object.getPrototypeOf"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("left"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(", // 获取对象的原型\n    prototype "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" right.prototype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" // 获取构造函数的 prototype 对象\n\n  // 判断构造函数的 prototype 对象是否在对象的原型链上\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("true"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("proto"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("proto "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" prototype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    proto "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Object.getPrototypeOf"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("proto"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h3",{attrs:{id:"_14-new-操作符具体干了什么呢-如何实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_14-new-操作符具体干了什么呢-如何实现"}},[t._v("#")]),t._v(" 14. new 操作符具体干了什么呢？如何实现？")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("// （1）首先创建了一个新的空对象\n// （2）设置原型，将对象的原型设置为函数的 prototype 对象。\n// （3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）\n// （4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。\n\n// 实现:\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-name function"}},[t._v("objectFactory")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("let")]),t._v(" newObject "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" null,\n    constructor "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Array.prototype.shift.call"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arguments"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(",\n    result "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" null"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  // 参数判断\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("typeof constructor "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"function"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console.error"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"type error"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("return")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n  // 新建一个空对象，对象的原型为构造函数的 prototype 对象\n  newObject "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Object.create"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("constructor.prototype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  // 将 this 指向新建对象，并执行函数\n  result "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" constructor.apply"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("newObject, arguments"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  // 判断返回对象\n  "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("let")]),t._v(" flag "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("\n    result "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("typeof result "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"object"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" typeof result "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"function"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  // 判断返回结果\n  "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("return")]),t._v(" flag ? result "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v(":")]),t._v(" newObject"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n// 使用方法\n// objectFactory"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("构造函数, 初始化参数"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("h3",{attrs:{id:"_15-javascript-中-有一个函数-执行时对象查找时-永远不会去查找原型-这个函数是"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_15-javascript-中-有一个函数-执行时对象查找时-永远不会去查找原型-这个函数是"}},[t._v("#")]),t._v(" 15. Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("hasOwnProperty\n\n所有继承了 Object 的对象都会继承到 hasOwnProperty 方法。这个方法可以用来检测一个对象是否含有\n特定的自身属性，和in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。\n")])])]),s("h3",{attrs:{id:"_16-foreach-call-function-a-a-style-outline-1px-solid-math-random-1-24-tostring-16-能解释一下这段代码的意思吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_16-foreach-call-function-a-a-style-outline-1px-solid-math-random-1-24-tostring-16-能解释一下这段代码的意思吗"}},[t._v("#")]),t._v(' 16. [].forEach.call($$(""),function(a){a.style.outline="1px solid #"+(~~(Math.random()(1<<24))).toString(16)}) 能解释一下这段代码的意思吗？')]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("（1）选取页面所有 DOM 元素。在浏览器的控制台中可以使用"),s("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("方法来获取页面中相应的元素，这是现代\n  浏览器提供的一个命令行 API 相当于 document.querySelectorAll 方法。\n\n（2）循环遍历 DOM 元素\n\n（3）给元素添加 outline 。由于渲染的 outline 是不在 CSS 盒模型中的，所以为元素添加 outline \n  并不会影响元素的大小和页面的布局。\n\n（4）生成随机颜色函数。Math.random"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("*"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[s("span",{pre:!0,attrs:{class:"token file-descriptor important"}},[t._v("1")]),t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("24")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" 可以得到 "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("~2^24 - "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" 之间的随机数，因为得到的是\n  一个浮点数，但我们只需要整数部分，使用取反操作符 ~ 连续两次取反获得整数部分，然后再用 toString\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("16")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" 的方式，转换为一个十六进制的字符串。\n\n")])])]),s("h3",{attrs:{id:"_17-js-延迟加载的方式有哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_17-js-延迟加载的方式有哪些"}},[t._v("#")]),t._v(" 17. js 延迟加载的方式有哪些？")]),t._v(" "),s("blockquote",[s("p",[t._v("js 延迟加载，也就是等页面加载完成之后再加载 JavaScript 文件。js 延迟加载有助于提高页面加载速度。")])]),t._v(" "),s("p",[t._v("一般有以下几种方式：")]),t._v(" "),s("p",[t._v("defer 属性\nasync 属性\n动态创建 DOM 方式\n使用 setTimeout 延迟方法\n让 JS 最后加载")]),t._v(" "),s("p",[t._v("回答：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高\n页面的渲染速度。\n\n我了解到的几种方式是：\n\n第一种方式是我们一般采用的是将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。\n\n第二种方式是给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在\n文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的\n脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。\n\n第三种方式是给 js 脚本添加 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("async")]),t._v(" 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，\n但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("async")]),t._v(" \n属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。\n\n第四种方式是动态创建 "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("DOM")]),t._v(" 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态\n的创建script 标签来引入 js 脚本。\n")])])]),s("h3",{attrs:{id:"_18-ajax-是什么-如何创建一个-ajax"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_18-ajax-是什么-如何创建一个-ajax"}},[t._v("#")]),t._v(" 18. Ajax 是什么? 如何创建一个 Ajax？")]),t._v(" "),s("blockquote",[s("p",[t._v("相关知识点：")])]),t._v(" "),s("p",[t._v("2005 年 2 月，AJAX 这个词第一次正式提出，它是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。")]),t._v(" "),s("p",[t._v("具体来说，AJAX 包括以下几个步骤。")]),t._v(" "),s("p",[t._v("1.创建 XMLHttpRequest 对象，也就是创建一个异步调用对象\n2.创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息\n3.设置响应 HTTP 请求状态变化的函数\n4.发送 HTTP 请求\n5.获取异步调用返回的数据\n6.使用 JavaScript 和 DOM 实现局部刷新")]),t._v(" "),s("p",[t._v("一般实现：")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("const SERVER_URL "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"/server"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("let")]),t._v(" xhr "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" new XMLHttpRequest"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n// 创建 Http 请求\nxhr.open"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"GET"')]),t._v(", SERVER_URL, "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n// 设置状态监听函数\nxhr.onreadystatechange "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-name function"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("this.readyState "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("return")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  // 当请求成功时\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("this.status "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("200")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    handle"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("this.response"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console.error"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("this.statusText"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n// 设置请求失败时的监听函数\nxhr.onerror "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-name function"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  console.error"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("this.statusText"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n// 设置请求头信息\nxhr.responseType "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"json"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nxhr.setRequestHeader"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Accept"')]),t._v(", "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"application/json"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n// 发送 Http 请求\nxhr.send"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("null"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n// promise 封装实现：\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" getJSON"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("url"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  // 创建一个 promise 对象\n  "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("let")]),t._v(" promise "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" new Promise"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("function"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("resolve, reject"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("let")]),t._v(" xhr "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" new XMLHttpRequest"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    // 新建一个 http 请求\n    xhr.open"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"GET"')]),t._v(", url, "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    // 设置状态的监听函数\n    xhr.onreadystatechange "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-name function"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("this.readyState "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("return")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n      // 当请求成功或失败时，改变 promise 的状态\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("this.status "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("200")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        resolve"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("this.response"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        reject"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("new Error"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("this.statusText"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("))")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    // 设置错误监听函数\n    xhr.onerror "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-name function"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      reject"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("new Error"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("this.statusText"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("))")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    // 设置响应的数据类型\n    xhr.responseType "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"json"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    // 设置请求头信息\n    xhr.setRequestHeader"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Accept"')]),t._v(", "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"application/json"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    // 发送 http 请求\n    xhr.send"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("null"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("return")]),t._v(" promise"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("我对 ajax 的理解是，它是一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 通信，\n然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。\n\n创建一个 ajax 有这样几个步骤\n\n首先是创建一个 XMLHttpRequest 对象。\n\n然后在这个对象上使用 open 方法创建一个 http 请求，open 方法所需要的参数是请求的方法、请求的地址、\n是否异步和用户的认证信息。\n\n在发起请求前，我们可以为这个对象添加一些信息和监听函数。比如说我们可以通过 setRequestHeader \n方法来为请求添加头信息。我们还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象\n一共有 "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v(" 个状态，当它的状态变化时会触发onreadystatechange 事件，我们可以通过设置监听函数，\n来处理请求成功后的结果。当对象的 readyState 变为 "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),t._v(" 的时候，代表服务器返回的数据接收完成，这个\n时候我们可以通过判断请求的状态，如果状态是 2xx 或者 "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("304")]),t._v(" 的话则代表返回正常。这个时候我们就可以\n通过 response 中的数据来对页面进行更新了。\n\n当对象的属性和监听函数设置完成后，最后我们调用 sent 方法来向服务器发起请求，可以传入参数作为发送\n的数据体。\n")])])]),s("h3",{attrs:{id:"_19-谈一谈浏览器的缓存机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_19-谈一谈浏览器的缓存机制"}},[t._v("#")]),t._v(" 19. 谈一谈浏览器的缓存机制？")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("浏览器的缓存机制指的是通过在一段时间内保留已接收到的 web 资源的一个副本，如果在资源的有效时间内，\n发起了对这个资源的再一次请求，那么浏览器会直接使用缓存的副本，而不是向服务器发起请求。使用 web \n缓存可以有效地提高页面的打开速度，减少不必要的网络带宽的消耗。\n\nweb 资源的缓存策略一般由服务器来指定，可以分为两种，分别是强缓存策略和协商缓存策略。\n\n使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。强缓存策略可以通过\n两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Control 属性。\n\n服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，\n不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端\n的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。\n\nExpires 是 http1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" 中的方式，因为它的一些缺点，在 http "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.1")]),t._v(" 中提出了一个新的头部属性就是 Cache"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Control 属性，\n它提供了对资源的缓存的更精确的控制。它有很多不同的值，常用的比如我们可以通过设置 max"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("age 来指定资源\n能够被缓存的时间的大小，这是一个相对的时间，它会根据这个时间的大小和资源第一次请求时的时间来计算出资源\n过期的时间，因此相对于 Expires来说，这种方式更加有效一些。常用的还有比如 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" ，用来规定资源只能\n被客户端缓存，不能够代理服务器所缓存。还有如 no"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("store ，用来指定资源不能够被缓存，no"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("cache 代表该资\n源能够被缓存，但是立即失效，每次都需要向服务器发起请求。\n\n一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Control 的优先级要\n高于 Expires 。\n\n使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("304")]),t._v(" 状态，让浏览器使用\n本地的缓存副本。\n如果资源发生了修改，则返回修改后的资源。协商缓存也可以通过两种方式来设置，分别是 http 头信息中的 Etag\n 和 Last"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Modified 属性。\n\n服务器通过在响应头中添加 Last"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，\n会在请求头中添加一个 If"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Modified"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Since 的属性，属性值为上一次资源返回时的 Last"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Modified 的值。\n当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做\n了修改。如果资源没有修改，那么返回 "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("304")]),t._v(" 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修\n改后的资源。使用这种方法有一个缺点，就是 Last"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Modified 标注的最后修改时间只能精确到秒级，如果某些\n文件在"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("秒钟以内，被修改多次的话，那么文件已将改变了但是 Last"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Modified 却没有改变，这样会造成缓存命\n中的不准确。\n\n因为 Last"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器\n在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，\n这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("None"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Match 属性，这个属性的\n值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，\n以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Modified 的方式更加精确。\n\n当 Last"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要\n考虑负载平衡的问题，因此多个服务器上资源的 Last"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Modified 应该保持一致，因为每个服务器上 Etag 的\n值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。\n\n强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一\n次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存\n策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果\n不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器\n直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。\n")])])]),s("h3",{attrs:{id:"_20-ajax-解决浏览器缓存问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_20-ajax-解决浏览器缓存问题"}},[t._v("#")]),t._v(" 20. Ajax 解决浏览器缓存问题？")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(".在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"If-Modified-Since"')]),t._v(","),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("。\n\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(".在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Cache-Control"')]),t._v(","),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"no-cache"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("。\n\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v(".在 URL 后面加上一个随机数："),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"fresh="')]),t._v(" + Math.random"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("。\n\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),t._v(".在 URL 后面加上时间戳："),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"nowtime="')]),t._v(" + new Date"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(".getTime"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("。\n\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v(".如果是使用 jQuery，直接这样就可以了$.ajaxSetup"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("cache:false"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("。这样页面的所有 ajax 都会\n执行这条语句就是不需要保存缓存记录。\n")])])])])}),[],!1,null,null,null);s.default=e.exports}}]);
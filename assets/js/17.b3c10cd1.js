(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{457:function(t,s,a){"use strict";a.r(s);var e=a(4),n=Object(e.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h3",{attrs:{id:"_1-vue的基本原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-vue的基本原理"}},[t._v("#")]),t._v(" 1.  Vue的基本原理")]),t._v(" "),s("blockquote",[s("p",[t._v("当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty（vue3.0使用proxy ）将它们转为 getter/setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。\n每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依\n赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。")])]),t._v(" "),s("h3",{attrs:{id:"_2-双向数据绑定的原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-双向数据绑定的原理"}},[t._v("#")]),t._v(" 2.  双向数据绑定的原理")]),t._v(" "),s("blockquote",[s("p",[t._v("Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。")])]),t._v(" "),s("p",[t._v("主要分为以下几个步骤：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("、需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的\n  话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("、compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应\n  的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("、Watcher订阅者是Observer和Compile之间通信的桥梁，\n  "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("主要做的事情是")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" \n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("①在自身实例化时往属性订阅器")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("dep"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("里面添加自己 \n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("②自身必须有一个update")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("方法 \n  ③待属性变动dep"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("notice")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("通知时，能调用自身的update")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("方法，并触发Compile中绑定的回调，则功成身退。\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),t._v("、"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("MVVM")]),t._v("作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己\n  的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile\n  之间的通信桥梁，达到数据变化 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("视图更新；视图交互变化")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("input"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" 数据model变更的双向绑\n  定效果。\n")])])]),s("h3",{attrs:{id:"_3-使用-object-defineproperty-来进行数据劫持有什么缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-使用-object-defineproperty-来进行数据劫持有什么缺点"}},[t._v("#")]),t._v(" 3. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？")]),t._v(" "),s("blockquote",[s("p",[t._v("在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。")])]),t._v(" "),s("blockquote",[s("p",[t._v("在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。")])]),t._v(" "),s("h3",{attrs:{id:"_4-mvvm的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-mvvm的理解"}},[t._v("#")]),t._v(" 4. MVVM的理解")]),t._v(" "),s("p",[t._v("MVVM 分为 Model、View、ViewModel：")]),t._v(" "),s("blockquote",[s("p",[t._v("Model代表数据模型，数据和业务逻辑都在Model层中定义；")])]),t._v(" "),s("blockquote",[s("p",[t._v("View代表UI视图，负责数据的展示；")])]),t._v(" "),s("blockquote",[s("p",[t._v("ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数\n据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数\n据也会在Model中同步。\n\n这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需\n要自己操作"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("DOM")]),t._v("。\n")])])]),s("h3",{attrs:{id:"_5-computed-和-watch-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-computed-和-watch-的区别"}},[t._v("#")]),t._v(" 5.  Computed 和 Watch 的区别?")]),t._v(" "),s("blockquote",[s("p",[t._v("computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。")])]),t._v(" "),s("blockquote",[s("p",[t._v("watch 侦听器 : 更多的是观察的作用，无缓存性，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。")])]),t._v(" "),s("p",[t._v("运用场景：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("当需要进行数值计算"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存\n特性，避免每次获取值时都要重新计算。\n\n当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("作")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" 访问一个 "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("API")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属\n性无法做到的\n")])])]),s("p",[t._v("对于Computed：")]),t._v(" "),s("blockquote",[s("p",[t._v("它支持缓存，只有依赖的数据发生了变化，才会重新计算\n不支持异步，当Computed中有异步操作时，无法监听数据的变化\ncomputed的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的。\n如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed\n如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。")])]),t._v(" "),s("p",[t._v("对于Watch:")]),t._v(" "),s("blockquote",[s("p",[t._v("它不支持缓存，数据变化时，它就会触发相应的操作\n支持异步监听\n监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值\n当一个属性发生变化时，就需要执行相应的操作\n监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个的参数：")]),t._v(" "),s("blockquote",[s("p",[t._v("immediate：组件加载立即触发回调函数")])])]),t._v(" "),s("blockquote",[s("blockquote",[s("p",[t._v("deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。")])])]),t._v(" "),s("blockquote",[s("p",[t._v("当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch。")])]),t._v(" "),s("h3",{attrs:{id:"_6-computed-和-methods-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-computed-和-methods-的区别"}},[t._v("#")]),t._v(" 6. Computed 和 Methods 的区别?")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("computed")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" 计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值；\n\n"),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("method")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" 调用总会执行该函数。\n")])])]),s("h3",{attrs:{id:"_7-slot是什么-有什么作用-原理是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-slot是什么-有什么作用-原理是什么"}},[t._v("#")]),t._v(" 7.  slot是什么？有什么作用？原理是什么？")]),t._v(" "),s("blockquote",[s("p",[t._v("slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。slot又分三类，默认插槽，具名插槽和作用域插槽。")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("默认插槽")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("又名匿名插槽，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个\n匿名插槽。\n\n"),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("具名插槽")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。\n\n"),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("作用域插槽")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是\n在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的\n数据决定如何渲染该插槽。\n")])])]),s("blockquote",[s("p",[t._v("实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在vm.$slot中，默认插槽为vm.$slot.default，具名插槽为vm.$slot.xxx，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用$slot中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。")])]),t._v(" "),s("h3",{attrs:{id:"_8-过滤器的作用-如何实现一个过滤器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-过滤器的作用-如何实现一个过滤器"}},[t._v("#")]),t._v(" 8.  过滤器的作用，如何实现一个过滤器?")]),t._v(" "),s("blockquote",[s("p",[t._v("根据过滤器的名称，过滤器是用来过滤数据的，在Vue中使用"),s("code",[t._v("filters")]),t._v("来过滤数据，"),s("code",[t._v("filters")]),t._v("不会修改数据，而是过滤数据，改变用户看到的输出（计算属性 "),s("code",[t._v("computed")]),t._v(" ，方法 "),s("code",[t._v("methods")]),t._v(" 都是通过修改数据来处理数据格式的输出显示）。")])]),t._v(" "),s("blockquote",[s("p",[t._v("使用场景：需要格式化数据的情况，比如需要处理时间、价格等数据格式的输出 / 显示。\n比如后端返回一个 年月日的日期字符串，前端需要展示为 多少天前 的数据格式，此时就可以用fliters过滤器来处理数据。")])]),t._v(" "),s("blockquote",[s("p",[t._v("过滤器是一个函数，它会把表达式中的值始终当作函数的第一个参数。过滤器用在插值表达式 "+t._s()+" 和 v-bind 表达式 中，然后放在操作符“ | ”后面进行指示。")])]),t._v(" "),s("p",[t._v("例如，在显示金额，给商品价格添加单位：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("li"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("商品价格："),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("item"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("price "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" filterPrice"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("li"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\n "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("filters")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("filterPrice")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("price")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" price "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'￥'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" price"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'--'")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),s("h3",{attrs:{id:"_9-如何保存页面的当前的状态"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-如何保存页面的当前的状态"}},[t._v("#")]),t._v(" 9. 如何保存页面的当前的状态")]),t._v(" "),s("p",[t._v("既然是要保持页面的状态（其实也就是组件的状态），那么会出现以下两种情况：")]),t._v(" "),s("p",[t._v("前组件会被卸载")]),t._v(" "),s("p",[t._v("前组件不会被卸载")]),t._v(" "),s("p",[t._v("组件会被卸载：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("（"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("）将状态存储在LocalStorage "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" SessionStorage\n  只需要在组件即将被销毁的生命周期 componentWillUnmount （react）中在LocalStorage "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("\n  SessionStorage 中把当前组件的 state 通过 "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("JSON")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("stringify")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" 储存下来就可以了。在这里\n  面需要注意的是组件更新状态的时机。\n  比如从 "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("B")]),t._v(" 组件跳转到 "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("A")]),t._v(" 组件的时候，"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("A")]),t._v(" 组件需要更新自身的状态。但是如果从别的组件跳转到 "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("B")]),t._v(" 组\n  件的时候，实际上是希望 "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("B")]),t._v(" 组件重新渲染的，也就是不要从 Storage 中读取信息。所以需要在 \n  Storage 中的状态加入一个 flag 属性，用来控制 "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("A")]),t._v(" 组件是否读取 Storage 中的状态。\n优点：\n\n兼容性好，不需要额外库或工具。\n简单快捷，基本可以满足大部分需求。\n\n缺点：\n\n状态通过 "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("JSON")]),t._v(" 方法储存（相当于深拷贝），如果状态中有特殊情况（比如 Date 对象、Regexp 对象\n等）的时候会得到字符串而不是原来的值。（具体参考用 "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("JSON")]),t._v(" 深拷贝的缺点）\n\n如果 "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("B")]),t._v(" 组件后退或者下一页跳转并不是前组件，那么 flag 判断会失效，导致从其他页面进入 "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("A")]),t._v(" 组件\n页面时 "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("A")]),t._v(" 组件会重新读取 Storage，会造成很奇怪的现象\n")])])]),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("）路由传值\n通过 react"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("router 的 Link 组件的 prop —— to 可以实现路由间传递参数的效果。\n在这里需要用到 state 参数，在 "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("B")]),t._v(" 组件中通过 history"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("location"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("state 就可以拿到 state 值，保存它。返回 "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("A")]),t._v(" 组件时再次携带 state 达到路由状态保持的效果。\n优点：\n\n简单快捷，不会污染 LocalStorage "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" SessionStorage。\n可以传递 Date、RegExp 等特殊对象（不用担心 "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("JSON")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("stringify "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" parse 的不足）\n\n缺点：\n\n如果 "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("A")]),t._v(" 组件可以跳转至多个组件，那么在每一个跳转组件内都要写相同的逻辑。\n")])])]),s("p",[t._v("组件不会被卸载：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("）单页面渲染\n要切换的组件作为子组件全屏渲染，父组件中正常储存页面状态。\n优点：\n\n代码量少\n不需要考虑状态传递过程中的错误\n\n缺点：\n\n增加 "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("A")]),t._v(" 组件维护成本"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("需要传入额外的 prop 到 "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("B")]),t._v(" 组件"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("无法利用路由定位页面\n\n除此之外，在Vue中，还可以是用keep"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("alive来缓存页面，当组件在keep"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("alive内被切换时组件的\nactivated、deactivated这两个生命周期钩子函数会被执行被包裹在keep"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("alive中的组件的状态\n将会被保留：\n\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("keep"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("alive"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("router"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("view v"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"$route.meta.keepAlive"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("router"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("view"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("kepp"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("alive"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\nrouter"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("js"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("path")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'/'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'xxx'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("component")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'../src/views/xxx.vue'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("meta")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("keepAlive")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 需要被缓存")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n")])])]),s("h3",{attrs:{id:"_10-v-if和v-show的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-v-if和v-show的区别"}},[t._v("#")]),t._v(" 10.  v-if和v-show的区别？")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("手段：v"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v("是动态的向"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("DOM")]),t._v("树内添加或者删除"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("DOM")]),t._v("元素；v"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("show是通过设置"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("DOM")]),t._v("元素的display样式属性\n控制显隐；\n\n编译过程：v"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v("切换有一个局部编译"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组\n件；v"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("show只是简单的基于css切换；\n\n编译条件：v"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v("是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编\n译"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" v"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("DOM")]),t._v("元素保留；\n\n性能消耗：v"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v("有更高的切换消耗；v"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("show有更高的初始渲染消耗；\n\n使用场景：v"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v("适合运营条件不大可能改变；v"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("show适合频繁切换。\n\n")])])]),s("h3",{attrs:{id:"_11-data为什么是一个函数而不是对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_11-data为什么是一个函数而不是对象"}},[t._v("#")]),t._v(" 11. data为什么是一个函数而不是对象?")]),t._v(" "),s("blockquote",[s("p",[t._v("JavaScript中的对象是引用类型的数据，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化。")])]),t._v(" "),s("blockquote",[s("p",[t._v("而在Vue中，更多的是想要复用组件，那就需要每个组件都有自己的数据，这样组件之间才不会相互干扰。")])]),t._v(" "),s("blockquote",[s("p",[t._v("所以组件的数据不能写成对象的形式，而是要写成函数的形式。数据以函数返回值的形式定义，这样当每次复用组件的时候，就会返回一个新的data，也就是说每个组件都有自己的私有数据空间，它们各自维护自己的数据，不会干扰其他组件的正常运行")])]),t._v(" "),s("h3",{attrs:{id:"_12-nexttick-原理及作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_12-nexttick-原理及作用"}},[t._v("#")]),t._v(" 12. $nextTick 原理及作用?")]),t._v(" "),s("p",[t._v("Vue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。")]),t._v(" "),s("blockquote",[s("p",[t._v("nextTick 的核心是利用了如 Promise 、MutationObserver、setImmediate、setTimeout的原生 JavaScript 方法来模拟对应的微/宏任务的实现，本质是为了利用 JavaScript 的这些异步回调任务队列来实现 Vue 框架中自己的异步回调队列。")])]),t._v(" "),s("p",[t._v("nextTick 是典型的将底层 JavaScript 执行原理应用到具体案例中的示例，引入异步更新队列机制的原因∶")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("如果是同步更新，则多次对一个或多个属性赋值，会频繁触发 "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("UI")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("DOM")]),t._v(" 的渲染，可以减少一些无用渲染\n\n同时由于 VirtualDOM 的引入，每一次状态发生变化后，状态变化的信号会发送给组件，组件内部使用\nVirtualDOM 进行计算得出需要更新的具体的 "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("DOM")]),t._v(" 节点，然后对 "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("DOM")]),t._v(" 进行更新操作，每次更新状态\n后的渲染过程需要更多的计算，而这种无用功也将浪费更多的性能，所以异步渲染变得更加至关重要\n")])])]),s("p",[t._v("所以，在以下情况下，会用到nextTick：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("DOM")]),t._v("结构的时候，这个操作就需要\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("方法在nextTick")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("的回调函数中。\n\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("在vue生命周期中，如果在created")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("钩子进行"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("DOM")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("操作，也一定要放在nextTick")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("的回调函数中。\n\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("因为在created")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("钩子函数中，页面的"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("DOM")]),t._v("还未渲染，这时候也没办法操作"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("DOM")]),t._v("，所以，此时如果想要操\n作"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("DOM")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("，必须将操作的代码放在nextTick")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("的回调函数中。\n")])])]),s("h3",{attrs:{id:"_13-vue-中给-data-中的对象属性添加一个新的属性时会发生什么-如何解决"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_13-vue-中给-data-中的对象属性添加一个新的属性时会发生什么-如何解决"}},[t._v("#")]),t._v(" 13.  Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("template"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" \n   "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("div"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("ul"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n         "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("li v"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"value in obj"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("key"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"value"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("li"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" \n      "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("ul"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" \n      "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("button @click"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"addObjB"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("添加 obj"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("b"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("button"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" \n   "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("div"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("template"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("script"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("default")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n       "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("data")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n          "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n              "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("obj")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n                  "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("a")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'obj.a'")]),t._v(" \n              "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \n          "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \n       "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n       "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("methods")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n          "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("addObjB")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n              "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("obj"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("b "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'obj.b'")]),t._v(" \n              console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("obj"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" \n          "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \n      "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("script"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),s("p",[t._v("点击 button 会发现，obj.b 已经成功添加，但是视图并未刷新。这是因为在Vue实例创建时，obj.b并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局 api $set()：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("addObjB")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("$set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("obj"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'b'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'obj.b'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n   console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("obj"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("blockquote",[s("p",[t._v("$set()方法相当于手动的去把obj.b处理成一个响应式的属性，此时视图也会跟着改变了")])]),t._v(" "),s("h3",{attrs:{id:"_14-vue-单页应用与多页应用的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_14-vue-单页应用与多页应用的区别"}},[t._v("#")]),t._v(" 14.  Vue 单页应用与多页应用的区别?")]),t._v(" "),s("p",[t._v("概念：")]),t._v(" "),s("blockquote",[s("p",[t._v("SPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。")])]),t._v(" "),s("blockquote",[s("p",[t._v("MPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新")])]),t._v(" "),s("h3",{attrs:{id:"_15-vue-data-中某一个属性的值发生改变后-视图会立即同步执行重新渲染吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_15-vue-data-中某一个属性的值发生改变后-视图会立即同步执行重新渲染吗"}},[t._v("#")]),t._v(" 15. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？")]),t._v(" "),s("blockquote",[s("p",[t._v("不会立即同步执行重新渲染。Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。")])]),t._v(" "),s("blockquote",[s("p",[t._v("如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环tick中，Vue 刷新队列并执行实际（已去重的）工作。")])]),t._v(" "),s("h3",{attrs:{id:"_16-子组件可以直接改变父组件的数据吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_16-子组件可以直接改变父组件的数据吗"}},[t._v("#")]),t._v(" 16. 子组件可以直接改变父组件的数据吗？")]),t._v(" "),s("blockquote",[s("p",[t._v("子组件不可以直接改变父组件的数据。这样做主要是为了维护父子组件的单向数据流。每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。如果这样做了，Vue 会在浏览器的控制台中发出警告。")])]),t._v(" "),s("blockquote",[s("p",[t._v("Vue提倡单向数据流，即父级 props 的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。")])]),t._v(" "),s("p",[s("strong",[t._v("只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。")])]),t._v(" "),s("h3",{attrs:{id:"_17-对-react-和-vue-的理解-它们的异同"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_17-对-react-和-vue-的理解-它们的异同"}},[t._v("#")]),t._v(" 17. 对 React 和 Vue 的理解，它们的异同?")]),t._v(" "),s("p",[t._v("相似之处：")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库；\n都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板；\n都使用了Virtual DOM（虚拟DOM）提高重绘性能；\n都有props的概念，允许组件间的数据传递；\n都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性。\n")])])]),s("p",[t._v("不同之处 ：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("）数据流\nVue默认支持数据双向绑定，而React一直提倡单向数据流\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("）虚拟"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("DOM")]),t._v("\nVue2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("x开始引入"),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Virtual DOM"')]),t._v("，消除了和React在这方面的差异，但是在具体的细节还是有各自的特\n点。\n\nVue宣称可以更快地计算出Virtual "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("DOM")]),t._v("的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关\n系，不需要重新渲染整个组件树。\n\n对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 \nPureComponent"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优\n化。\n\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("）组件化\nReact与Vue最大的不同是模板的编写。\n\nVue鼓励写近似常规"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("HTML")]),t._v("的模板。写起来很接近标准 "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("HTML")]),t._v("元素，只是多了一些属性。\nReact推荐你所有的模板通用JavaScript的语法扩展——"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("JSX")]),t._v("书写。\n\n具体来讲：React中render函数是支持闭包特性的，所以"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v("的组件在render中可以直接调用。但是\n在Vue中，由于模板中使用的数据都必须挂在 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),t._v(" 上进行一次中转，所以 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" 一个组件完了之\n后，还需要在 components 中再声明下。\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),t._v("）监听数据变化的实现原理不同\n\nVue 通过 getter"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很\n好的性能\n\nReact 默认是通过比较引用的方式进行的，如果不优化（PureComponent"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("\nshouldComponentUpdate）可能导致大量不必要的vDOM的重新渲染。这是因为 Vue 使用的是可变数\n据，而React更强调数据的不可变。\n\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v("）高阶组件\nreact可以通过高阶组件（"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("HOC")]),t._v("）来扩展，而Vue需要通过mixins来扩展。\n高阶组件就是高阶函数，而React的组件本身就是纯粹的函数，所以高阶函数对React来说易如反掌。\n相反Vue"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("js使用"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("HTML")]),t._v("模板创建视图组件，这时模板无法有效的编译，因此Vue不能采用"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("HOC")]),t._v("来实现。\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),t._v("）构建工具\n两者都有自己的构建工具：\n\nReact "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" Create React "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("APP")]),t._v("\n\nVue "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" vue"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("cli\n\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("7")]),t._v("）跨平台\n\nReact "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" React Native\n\nVue "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" Weex\n")])])]),s("h3",{attrs:{id:"_18-对ssr的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_18-对ssr的理解"}},[t._v("#")]),t._v(" 18. 对SSR的理解")]),t._v(" "),s("p",[t._v("SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html\n直接返回给客户端.")]),t._v(" "),s("p",[t._v("SSR的优势：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("更好的"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("SEO")]),t._v("\n\n首屏加载速度更快\n")])])]),s("p",[t._v("SSR的缺点：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子；\n\n当需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("js的运行环境；\n\n更多的服务端负载。\n")])])]),s("h3",{attrs:{id:"_19-vue的性能优化有哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_19-vue的性能优化有哪些"}},[t._v("#")]),t._v(" 19. Vue的性能优化有哪些?")]),t._v(" "),s("p",[t._v("（1）编码阶段")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher\nv"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v("和v"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v("不能连用\n如果需要使用v"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v("给每项元素绑定事件时使用事件代理\n"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("SPA")]),t._v(" 页面采用keep"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("alive缓存组件\n在更多的情况下，使用v"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v("替代v"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("show\nkey保证唯一\n使用路由懒加载、异步组件\n防抖、节流\n第三方模块按需导入\n长列表滚动到可视区域动态加载\n图片懒加载\n")])])]),s("p",[t._v("（2）SEO优化")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("预渲染\n服务端渲染"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("SSR")]),t._v("\n")])])]),s("p",[t._v("（3）打包优化")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("压缩代码\nTree Shaking"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("Scope Hoisting\n使用cdn加载第三方模块\n多线程打包happypack\nsplitChunks抽离公共文件\nsourceMap优化\n")])])]),s("p",[t._v("（4）用户体验")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("骨架屏\n"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("PWA")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("还可以使用缓存")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("客户端缓存、服务端缓存"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("优化、服务端开启gzip压缩等。\n")])])]),s("h3",{attrs:{id:"_20-对-spa-单页面的理解-它的优缺点分别是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_20-对-spa-单页面的理解-它的优缺点分别是什么"}},[t._v("#")]),t._v(" 20. 对 SPA 单页面的理解，它的优缺点分别是什么？")]),t._v(" "),s("blockquote",[s("p",[t._v("SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。")])]),t._v(" "),s("p",[s("strong",[t._v("优点：")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；\n基于上面一点，"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("SPA")]),t._v(" 相对对服务器压力小；\n前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；\n")])])]),s("p",[s("strong",[t._v("缺点：")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、\n"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CSS")]),t._v(" 统一加载，部分页面按需加载；\n\n前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，\n所有的页面切换需要自己建立堆栈管理；\n\n"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("SEO")]),t._v(" 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("SEO")]),t._v(" 上其有着天然的弱势。\n")])])]),s("h3",{attrs:{id:"_21、vue初始化页面闪动问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_21、vue初始化页面闪动问题"}},[t._v("#")]),t._v(" 21、vue初始化页面闪动问题")]),t._v(" "),s("blockquote",[s("p",[t._v("使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于"+t._s(t.message)+"的字样，虽然一般情况下这个时间很短暂，但是还是有必要让解决这个问题的。")])]),t._v(" "),s("p",[t._v("首先：在css里加上以下代码：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("v"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("cloak"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("    "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("display")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" none"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v('如果没有彻底解决问题，则在根元素加上style="display: none;" :style="{display: \'block\'}"')])])}),[],!1,null,null,null);s.default=n.exports}}]);
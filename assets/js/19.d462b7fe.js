(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{458:function(t,a,s){"use strict";s.r(a);var e=s(4),r=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"_1、vue3-0有什么更新"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、vue3-0有什么更新"}},[t._v("#")]),t._v(" 1、Vue3.0有什么更新？")]),t._v(" "),a("p",[a("strong",[t._v("（1）监测机制的改变")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("3.0 将带来基于代理 Proxy的 observer 实现，提供全语言覆盖的反应性跟踪。")])]),t._v(" "),a("li",[a("p",[t._v("消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：")])])]),t._v(" "),a("p",[a("strong",[t._v("（2）只能监测属性，不能监测对象")])]),t._v(" "),a("ul",[a("li",[t._v("检测属性的添加和删除；")]),t._v(" "),a("li",[t._v("检测数组索引和长度的变更；")]),t._v(" "),a("li",[t._v("支持 Map、Set、WeakMap 和 WeakSet。")])]),t._v(" "),a("p",[a("strong",[t._v("（3）模板")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。")])]),t._v(" "),a("li",[a("p",[t._v("同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。")])])]),t._v(" "),a("p",[t._v("（4）对象式的组件声明方式")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。")])]),t._v(" "),a("li",[a("p",[t._v("3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易")])])]),t._v(" "),a("p",[t._v("（5）其它方面的更改")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。")])]),t._v(" "),a("li",[a("p",[t._v("支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。")])]),t._v(" "),a("li",[a("p",[t._v("基于 tree shaking 优化，提供了更多的内置功能。")])])]),t._v(" "),a("h3",{attrs:{id:"_2、defineproperty和proxy的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、defineproperty和proxy的区别"}},[t._v("#")]),t._v(" 2、defineProperty和proxy的区别")]),t._v(" "),a("p",[a("strong",[t._v("Vue 在实例初始化时遍历 data 中的所有属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。这样当追踪数据发生变化时，setter 会被自动调用。")])]),t._v(" "),a("p",[t._v("但是这样做有以下问题：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("添加或删除对象的属性时，Vue 检测不到。因为添加或删除的对象没有在初始化进行响应式处理，只能通过$set 来调用Object.defineProperty()处理。")])]),t._v(" "),a("li",[a("p",[t._v("无法监控到数组下标和长度的变化。")])])]),t._v(" "),a("blockquote",[a("p",[t._v("Vue3 使用 Proxy 来监控数据的变化。Proxy 是 ES6 中提供的功能，其作用为："),a("strong",[t._v("用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）")]),t._v("。相对于Object.defineProperty()，其有以下特点")])]),t._v(" "),a("ul",[a("li",[t._v("Proxy 直接代理整个对象而非对象属性，这样只需做一层代理就可以监听同级结构下的所有属性变化，包括新增属性和删除属性。")]),t._v(" "),a("li",[t._v("Proxy 可以监听数组的变化。")])]),t._v(" "),a("h3",{attrs:{id:"_3、-vue3-0-为什么要用-proxy"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、-vue3-0-为什么要用-proxy"}},[t._v("#")]),t._v(" 3、 Vue3.0 为什么要用 proxy？")]),t._v(" "),a("blockquote",[a("p",[t._v("在 Vue2 中， 0bject.defineProperty 会改变原始数据，"),a("strong",[t._v("而 Proxy 是创建对象的虚拟表示，并提供 set 、get 和 deleteProperty 等处理器，这些处理器可在访问或修改原始对象上的属性时进行拦截")]),t._v("，有以下特点∶")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("不需用使用 Vue.$set 或 Vue.$delete 触发响应式。")])]),t._v(" "),a("li",[a("p",[t._v("全方位的数组变化检测，消除了Vue2 无效的边界情况。")])]),t._v(" "),a("li",[a("p",[t._v("支持 Map，Set，WeakMap 和 WeakSet。")])])]),t._v(" "),a("blockquote",[a("p",[t._v("Proxy 实现的响应式原理与 Vue2的实现原理相同，实现方式大同小异∶")])]),t._v(" "),a("ul",[a("li",[t._v("get 收集依赖")]),t._v(" "),a("li",[t._v("Set、delete 等触发依赖")]),t._v(" "),a("li",[t._v("对于集合类型，就是对集合对象的方法做一层包装：原方法执行后执行依赖相关的收集或触发逻辑。")])]),t._v(" "),a("h3",{attrs:{id:"_4、vue-3-0-中的-vue-composition-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、vue-3-0-中的-vue-composition-api"}},[t._v("#")]),t._v(" 4、Vue 3.0 中的 Vue Composition API？")]),t._v(" "),a("blockquote",[a("p",[t._v("在 Vue2 中，代码是 Options API 风格的，也就是通过填充 (option) data、methods、computed 等属性来完成一个 Vue 组件。这种风格使得 Vue 相对于 React极为容易上手，同时也造成了几个问题：")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("由于 Options API 不够灵活的开发方式，使得Vue开发缺乏优雅的方法来在组件间共用代码。")])]),t._v(" "),a("li",[a("p",[t._v("Vue 组件过于依赖this上下文，Vue 背后的一些小技巧使得 Vue 组件的开发看起来与 JavaScript 的开发原则相悖，比如在methods 中的this竟然指向组件实例来不指向methods所在的对象。这也使得 TypeScript 在Vue2 中很不好用。")])])]),t._v(" "),a("blockquote",[a("p",[t._v("于是在 Vue3 中，舍弃了 Options API，转而投向 Composition API。Composition API本质上是将 Options API 背后的机制暴露给用户直接使用，这样用户就拥有了更多的灵活性，也使得 Vue3 更适合于 TypeScript 结合。")])]),t._v(" "),a("p",[t._v("使用了 Vue Composition API 的 Vue3 组件:")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("template"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("button @click"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"increment"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("Count")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" count "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("button"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("template"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n \n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("script"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Composition API 将组件属性暴露为函数，因此第一步是导入所需的函数")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" ref"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" computed"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" onMounted "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'vue'")]),t._v("\n \n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("default")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setup")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 使用 ref 函数声明了称为 count 的响应属性，对应于Vue2中的data函数")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" count "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("ref")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n \n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Vue2中需要在methods option中声明的函数，现在直接声明")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("increment")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      count"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("value"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 对应于Vue2中的mounted生命周期")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("onMounted")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'component mounted!'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n \n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      count"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      increment\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("script"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),a("h3",{attrs:{id:"_5、composition-api与react-hook很像-区别是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5、composition-api与react-hook很像-区别是什么"}},[t._v("#")]),t._v(" 5、Composition API与React Hook很像，区别是什么？")]),t._v(" "),a("blockquote",[a("p",[t._v("从React Hook的实现角度看，React Hook是根据useState调用的顺序来确定下一次重渲染时的state是来源于哪个useState，所以出现了以下限制")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("不能在循环、条件、嵌套函数中调用Hook")])]),t._v(" "),a("li",[a("p",[t._v("必须确保总是在你的React函数的顶层调用Hook")])]),t._v(" "),a("li",[a("p",[t._v("useEffect、useMemo等函数必须手动确定依赖关系")])])]),t._v(" "),a("blockquote",[a("p",[t._v("而Composition API是基于Vue的响应式系统实现的，与React Hook的相比")])]),t._v(" "),a("ul",[a("li",[t._v("声明在setup函数内，一次组件实例化只调用一次setup，而React Hook每次重渲染都需要调用Hook，使得React的GC比Vue更有压力，性能也相对于Vue来说也较慢")]),t._v(" "),a("li",[t._v("Compositon API的调用不需要顾虑调用顺序，也可以在循环、条件、嵌套函数中使用")]),t._v(" "),a("li",[t._v("响应式系统自动实现了依赖收集，进而组件的部分的性能优化由Vue内部自己完成，而React Hook需要手动传入依赖，而且必须必须保证依赖的顺序，让useEffect、useMemo等函数正确的捕获依赖变量，否则会由于依赖不正确使得组件性能下降。")])]),t._v(" "),a("blockquote",[a("p",[t._v("虽然Compositon API看起来比React Hook好用，但是其设计思想也是借鉴React Hook的")])]),t._v(" "),a("h3",{attrs:{id:"_6、-对虚拟dom的理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6、-对虚拟dom的理解"}},[t._v("#")]),t._v(" 6、 对虚拟DOM的理解")]),t._v(" "),a("blockquote",[a("p",[t._v("从本质上来说，"),a("strong",[t._v("Virtual Dom是一个JavaScript对象")]),t._v("，通过对象的方式来表示DOM结构。将页面的状态抽象为JS对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次DOM修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能。")])]),t._v(" "),a("h3",{attrs:{id:"_7、虚拟dom的解析过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7、虚拟dom的解析过程"}},[t._v("#")]),t._v(" 7、虚拟DOM的解析过程")]),t._v(" "),a("ul",[a("li",[t._v("首先对将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。")]),t._v(" "),a("li",[t._v("当页面的状态发生改变，需要对页面的 DOM 的结构进行调整的时候，首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。")]),t._v(" "),a("li",[t._v("最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。")])]),t._v(" "),a("h3",{attrs:{id:"_8、diff算法的原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8、diff算法的原理"}},[t._v("#")]),t._v(" 8、DIFF算法的原理")]),t._v(" "),a("p",[a("strong",[t._v("在新老虚拟DOM对比时：")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换")])]),t._v(" "),a("li",[a("p",[t._v("如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)")])]),t._v(" "),a("li",[a("p",[t._v("比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。")])]),t._v(" "),a("li",[a("p",[t._v("匹配时，找到相同的子节点，递归比较子节点")])])]),t._v(" "),a("blockquote",[a("p",[t._v("在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从O(n3)降低值O(n)，也就是说，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。")])]),t._v(" "),a("h3",{attrs:{id:"_9、"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9、"}},[t._v("#")]),t._v(" 9、")]),t._v(" "),a("h3",{attrs:{id:"_10、"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10、"}},[t._v("#")]),t._v(" 10、")]),t._v(" "),a("h3",{attrs:{id:"_11、"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11、"}},[t._v("#")]),t._v(" 11、")]),t._v(" "),a("h3",{attrs:{id:"_12、"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12、"}},[t._v("#")]),t._v(" 12、")]),t._v(" "),a("h3",{attrs:{id:"_13、"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_13、"}},[t._v("#")]),t._v(" 13、")]),t._v(" "),a("h3",{attrs:{id:"_14、"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14、"}},[t._v("#")]),t._v(" 14、")]),t._v(" "),a("h3",{attrs:{id:"_15、"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_15、"}},[t._v("#")]),t._v(" 15、")]),t._v(" "),a("h3",{attrs:{id:"_16、"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_16、"}},[t._v("#")]),t._v(" 16、")]),t._v(" "),a("h3",{attrs:{id:"_17、"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_17、"}},[t._v("#")]),t._v(" 17、")]),t._v(" "),a("h3",{attrs:{id:"_18、"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_18、"}},[t._v("#")]),t._v(" 18、")])])}),[],!1,null,null,null);a.default=r.exports}}]);